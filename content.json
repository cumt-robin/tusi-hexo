{"pages":[{"title":"关于我","text":"Tusi，专注大前端技术分享与架构，关注用户体验","link":"/about/index.html"}],"posts":[{"title":"Angular4中使用jquery和bootstrap","text":"在angular开发中某些场景可能需要jquery和bootstrap，那么如何使用它们呢？ Angular中引用jquery安装第一步，我们使用npm安装jquery 1npm install --save jquery 使用我们在ts文件中引入jquery。 123import * as $ from &apos;jquery&apos;;// 可以在ngOninit方法中打印进行测试console.log($(&apos;body&apos;)); 引入jquery类型在使用过程中，好像是没有什么问题的，但是好像通过点号调用jquery方法时，没有任何代码提示（我使用的是VSCode）。原因是编辑器不识别jquery的类型，所以不知道jquery中可以调用哪些方法。因此我们需要引入类型。 1npm install --save @types/jquery 这个时候，我们再通过点号调用jquery方法时，就会有代码提示了。如： 1$('body').hide(); Angular中引用bootstrap如何在angular中使用bootstrap呢？方法是差不多的。首先我们安装bootstrap。 1npm install --save bootstrap 我们主要用到的是bootstrap.min.css和bootstrap.min.js。需要在.angular-cli.json中进行配置。 1234567\"styles\": [ \"styles.css\", \"../node_modules/bootstrap/dist/css/bootstrap.min.css\"],\"scripts\": [ \"../node_modules/bootstrap/dist/js/bootstrap.min.js\"] 我配置之后还是不生效，可能是由于我ng eject后配置出了些问题，后续改下webpack配置应该可以实现。这里我先放在index.html中引用了。 12345&lt;!-- 引入js --&gt;&lt;script src=\"./node_modules/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./node_modules/bootstrap/dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入css --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./node_modules/bootstrap/dist/css/bootstrap.min.css\"&gt; 配置完成后，localhost可以正常使用bootstrap了。但是打包时出现问题了。因为index.html引用的是node_modules里面的资源，而我的webpack资源配置没有加上它们，导致404问题。于是我把这三个文件放在了assets里面，改成如下引用方式： 123&lt;script src=\"assets/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"assets/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"assets/css/bootstrap.min.css\"&gt;","link":"/Angular4中使用jquery和bootstrap.html"},{"title":"CentOS7系统下修改mysql8.0版本密码","text":"前言忘记mysql登录密码是很常见的操作，今天讲一下linux centos7下mysql8.0版本修改密码的方法。 踩坑网上很多文章说的是mysql5.x版本的修改密码方法，按照这些方法做就会遇到坑了。 忘记密码了，首先尝试修改mysql的配置文件/etc/my.cnf，有的人安装目录可能不太一样，配置文件会是/etc/mysql/my.cnf或者其他的目录下。 在[mysqld]下面添加一行，可以跳过密码登录 1skip-grant-tables 重启mysqld服务 1service mysqld restart 输入mysql回车进入mysql命令行，尝试执行 1update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;; 直接就报语句错误了，看来可能是password函数有问题。 ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘(“123456”) where user=”root”‘ at line 1 接着尝试另一个方法。 1mysql&gt; ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos; 也报错，–skip-grant-tables模式下，不能运行这条语句。 ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement 于是我先查查user表的数据。 1select user, password from user 发现user表中根本没有password这个字段，上网查了后发现只有authentication_string，在mysql5.7.9后就废弃了password字段和password()函数。 需要先将authentication_string设置为空 1update user set authentication_string = ‘’ where user = ‘root’; 然后退出mysql，删除/etc/my.cnf的skip-grant-tables，重启mysqld服务。 接着尝试登录mysql 1mysql -uroot -p 直接回车登录mysql，再使用alter修改用户密码 1alter user ‘root’@’%’ indentified by ‘123456’; 提示成功！！！","link":"/CentOS7系统下修改mysql8-0版本密码.html"},{"title":"CentOS7系统下安装mysql8.0.13版本","text":"1.进入到https://www.mysql.com/downloads/msyql下载页，选择社区版 2.查看linux版本，选择对应的版本下载 3.将下载的文件mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz拷贝到linux服务器上的某目录下，然后解压，再复制到usr/local目录，并改名为mysql 1234[root@VM_0_14_centos mysql]# tar -xvf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz[root@VM_0_14_centos mysql]# cp -rv mysql-8.0.13-linux-glibc2.12-x86_64 /usr/local[root@VM_0_14_centos mysql]# cd /usr/local [root@VM_0_14_centos local]# mv mysql-8.0.13-linux-glibc2.12-x86_64 mysql 4.添加mysql用户 1useradd -s /sbin/nologin -M mysql 5.msyql初始化 1/usr/local/mysql/bin/mysqld --initialize --user=mysql 此时会生成临时密码 1234[root@VM_0_14_centos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql2019-01-20T10:56:07.718326Z 0 [System] [MY-013169] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) initializing of server in progress as process 58262019-01-20T10:56:16.915217Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: twi=Tlsi&lt;0O!2019-01-20T10:56:20.410563Z 0 [System] [MY-013170] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) initializing of server has completed 6.复制启动、关闭脚本 1cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 7.修改配置文件，wq保存退出 12345678910vim /etc/my.cnf[mysqld] basedir = /usr/local/mysql datadir = /var/lib/mysql socket = /var/lib/mysql/mysql.sock character-set-server=utf8 [client] socket = /var/lib/mysql/mysql.sock default-character-set=utf8 8.启动数据库服务 1service mysqld start 报错 mysqld_safe Directory ‘/var/lib/mysql’ for UNIX socket file don’t exists. 一是因为没有/var/lib/mysql这个目录，二是没有写的权限，mysql.sock文件无法生成。 12[root@VM_0_14_centos lib]# mkdir mysql[root@VM_0_14_centos lib]# chmod 777 /var/lib/mysql 再次运行service mysqld start报另一个错 1Starting MySQL. ERROR! The server quit without updating PID file (/var/lib/mysql/VM_0_14_centos.pid). 打印出具体报错信息 1234567891011121314[root@VM_0_14_centos mysql]# cat VM_0_14_centos.err2019-01-20T11:11:45.906800Z 0 [System] [MY-010116] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) starting as process 77882019-01-20T11:11:45.910813Z 0 [Warning] [MY-013242] [Server] --character-set-server: &apos;utf8&apos; is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.2019-01-20T11:11:45.925456Z 1 [ERROR] [MY-011011] [Server] Failed to find valid data directory.2019-01-20T11:11:45.925586Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.2019-01-20T11:11:45.925600Z 0 [ERROR] [MY-010119] [Server] Aborting2019-01-20T11:11:45.926342Z 0 [System] [MY-010910] [Server] /usr/local/mysql/bin/mysqld: Shutdown complete (mysqld 8.0.13) MySQL Community Server - GPL.2019-01-20T11:12:00.049920Z 0 [System] [MY-010116] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) starting as process 79752019-01-20T11:12:00.052469Z 0 [Warning] [MY-013242] [Server] --character-set-server: &apos;utf8&apos; is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.2019-01-20T11:12:00.060600Z 1 [ERROR] [MY-011011] [Server] Failed to find valid data directory.2019-01-20T11:12:00.060745Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.2019-01-20T11:12:00.060759Z 0 [ERROR] [MY-010119] [Server] Aborting2019-01-20T11:12:00.061610Z 0 [System] [MY-010910] [Server] /usr/local/mysql/bin/mysqld: Shutdown complete (mysqld 8.0.13) MySQL Community Server - GPL. 看不出来具体是哪里的问题，于是运行service –status-all，有报错信息 ERROR! MySQL is not running, but lock file (/var/lock/subsys/mysql) exists 有网友说删了该文件就可以，结果我删了也没用。 那就接着排查刚才的err文件，关键的错误应该是这两行 122019-01-20T11:11:45.925456Z 1 [ERROR] [MY-011011] [Server] Failed to find valid data directory.2019-01-20T11:11:45.925586Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed. 于是查找my.cnf，与data目录有关的就是datadir=/var/lib/mysql这一条配置了，我尝试性地删了这一行，结果成功了，service mysqld start成功！ 9.mysql -u root -p登录mysql报错解决方法如下： 12cd /usr/local/bin ln -fs /usr/local/mysql/bin/mysql mysql 10.show databases报错 1you must reset your password using ALTER USER statement before executing this statement. 解决方法： 1alter user user() identified by &apos;123456&apos;; 11.用ip无法远程登录mysql，只能用localhost在linux服务器登录修改权限配置 1grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123456&apos;; 但是报错 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘identified by ‘123456’ at line 1 解决方法： 123use mysql;update user set host = &apos;%&apos; where user = &apos;root&apos;;flush privileges; 接着用navicat连接时报错 Client does not support authentication protocol requested by server; consider upgrading MySQL client 解决方法： 1ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;","link":"/CentOS7系统下安装mysql8-0-13版本.html"},{"title":"让Nodejs支持HTML5 History模式","text":"导读本文主要是对connect-history-api-fallback库进行一次源码分析。connect-history-api-fallback是一个用于支持SPA History路由模式的nodejs库。阅读本文前，应对HTML5 History模式有一定程度的了解！ 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/** * 前端需要开启history模式，而后端根据url并不知道前端在请求api还是在请求页面，如localhost:4200/home这种url，前端理所当然认为“我需要得到html，并跳转到首页”，然而后端并不能区分。 * 因此需要一种判断机制，来使得后端能分析出前端的请求目的。 * connect-history-api-fallback 这个中间件正好帮我们完成了上述分析操作，来看下它是怎么实现的吧！ * 第一次把自己的源码分析思路写出来，说得不对的地方，请指出！ */'use strict';var url = require('url');exports = module.exports = function historyApiFallback(options) { // 接收配置参数 options = options || {}; // 初始化日志管理器 var logger = getLogger(options); // 中间件是要返回一个函数的，函数形参有req, res, next return function(req, res, next) { var headers = req.headers; if (req.method !== 'GET') { // 如果请求方法不是GET类型，说明不需要返回html，那么就调用next()，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the method is not GET.' ); return next(); } else if (!headers || typeof headers.accept !== 'string') { // 如果没有请求头，或者请求头中的accept不是字符串，说明不是一个标准的http请求，也不予处理，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the client did not send an HTTP accept header.' ); return next(); } else if (headers.accept.indexOf('application/json') === 0) { // 如果客户端希望得到application/json类型的响应，说明也不是在请求html，也不予处理，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the client prefers JSON.' ); return next(); } else if (!acceptsHtml(headers.accept, options)) { // 如果请求头中不包含配置的Accept或者默认的['text/html', '*/*']，那么说明也不是在请求html，也不予处理，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the client does not accept HTML.' ); return next(); } // 走到这里说明是在请求html了，要开始秀操作了 // 首先利用url模块的parse方法解析下url，会得到一个对象，包括protocol，hash，path, pathname, query, search等字段，类似浏览器的location对象 var parsedUrl = url.parse(req.url); var rewriteTarget; // 然后得到配置中的rewrites，也就是重定向配置； // 重定向配置是一个数组，每一项都包含from和to两个属性； // from是用来正则匹配pathname是否需要重定向的; // to则是重定向的url，to可以是一个字符串，也可以是一个回调方法来返回一个字符串，回调函数接收一个上下文参数context，context包含三个属性（parsedUrl，match，request） options.rewrites = options.rewrites || []; // 遍历一波重定向配置 for (var i = 0; i &lt; options.rewrites.length; i++) { var rewrite = options.rewrites[i]; // 利用字符串的match方法去匹配 var match = parsedUrl.pathname.match(rewrite.from); if (match !== null) { // 如果match不是null，说明pathname和重定向配置匹配上了 rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req); if(rewriteTarget.charAt(0) !== '/') { // 推荐使用/开头的绝对路径作为重定向url logger( 'We recommend using an absolute path for the rewrite target.', 'Received a non-absolute rewrite target', rewriteTarget, 'for URL', req.url ); } logger('Rewriting', req.method, req.url, 'to', rewriteTarget); // 进行重定向url操作 req.url = rewriteTarget; return next(); } } var pathname = parsedUrl.pathname; // 首先说明一下：校验逻辑默认是会去检查url中最后的.号的，有.号的说明在请求文件，那就跟history模式就没什么鸟关系了 // 我暂且将上述规则成为“点号校验规则” // disableDotRule为true，代表禁用点号校验规则 if (pathname.lastIndexOf('.') &gt; pathname.lastIndexOf('/') &amp;&amp; options.disableDotRule !== true) { // 如果pathname的最后一个/之后还有.，说明请求的是/a/b/c/d.*的文件（*代表任意文件类型）; // 如果此时配置disableDotRule为false，说明开启点号校验规则，那么不予处理，交给其他中间件 logger( 'Not rewriting', req.method, req.url, 'because the path includes a dot (.) character.' ); return next(); } // 如果pathname最后一个/之后没有.，或者disableDotRule为true，都会走到最后一步：重写url // 重写url有默认值/index.html，也可以通过配置中的index自定义 rewriteTarget = options.index || '/index.html'; logger('Rewriting', req.method, req.url, 'to', rewriteTarget); // 重写url req.url = rewriteTarget; // 此时再将执行权交给下一个中间件（url都换成index.html了，后面的路由等中间件也不会再处理了，然后前端接收到html就开始解析路由了，目的达到！） next(); };};// 判断重定向配置中的tofunction evaluateRewriteRule(parsedUrl, match, rule, req) { if (typeof rule === 'string') { // 如果是字符串，直接返回 return rule; } else if (typeof rule !== 'function') { // 如果不是函数，抛出错误 throw new Error('Rewrite rule can only be of type string or function.'); } // 执行自定义的回调函数，得到一个重定向的url return rule({ parsedUrl: parsedUrl, match: match, request: req });}// 判断请求头的accept是不是包含在配置数组或默认数组的范围内function acceptsHtml(header, options) { options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*']; for (var i = 0; i &lt; options.htmlAcceptHeaders.length; i++) { if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) { return true; } } return false;}// 处理日志function getLogger(options) { if (options &amp;&amp; options.logger) { // 如果有指定的日志方法，则使用指定的日志方法 return options.logger; } else if (options &amp;&amp; options.verbose) { // 否则，如果配置了verbose，默认使用console.log作为日志方法 return console.log.bind(console); } // 否则就没有日志方法，就不记录日志咯 return function(){};}","link":"/History模式（connect-history-api-fallback源码分析）.html"},{"title":"PC截图时，怎么截住右键菜单？","text":"我昨天在写博客时，想要将右键菜单的图给截下来保存。于是乎，截图快捷键走起来。 1Ctrl + Alt + A 但是却发现利用QQ的截图快捷键竟然做不到，一按快捷键右键菜单就收起来了。多次尝试不果，所以就百度一下解决方案，当然很快就找到了答案。于是也写下来做下记录，希望能给还不知道的同学一点点帮助^_^。 方法就是： 右键呼出菜单，然后鼠标移动到某选项上，按住鼠标左键不动，然后再按截图的快捷键，这样就可以截图到右键菜单了。 快试一下吧！！！","link":"/PC截图时，怎么截住右键菜单？.html"},{"title":"Nodejs开发微信公众号--获取access_token","text":"为了梳理代码，我单独给微信的接口进行了一些封装。 这是前面认证接口的内容。 封装接口用到了request 1npm install --save request 封装的 js 结构大致是这样的 12345678910111213141516171819202122232425262728293031323334var request = require(&apos;request&apos;);var crypto = require(&apos;crypto&apos;);function WeChat(config) { this.config = config this.accessToken = null this.getAccessTokenTimer = null}WeChat.prototype.Authenticate = function(req, res) { //1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr var signature = req.query.signature,//微信加密签名 timestamp = req.query.timestamp,//时间戳 nonce = req.query.nonce,//随机数 echostr = req.query.echostr;//随机字符串 //2.将token、timestamp、nonce三个参数进行字典序排序 var array = [this.config.token,timestamp,nonce]; array.sort(); //3.将三个参数字符串拼接成一个字符串进行sha1加密 var tempStr = array.join(&apos;&apos;); const hashCode = crypto.createHash(&apos;sha1&apos;); //创建加密类型 var resultCode = hashCode.update(tempStr,&apos;utf8&apos;).digest(&apos;hex&apos;); //对传入的字符串进行加密 //4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 if(resultCode === signature){ res.send(echostr); }else{ res.send(&apos;mismatch&apos;); }}module.exports.WeChat = WeChat; 扯多了，回到正题access_token access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。 因此，我继续封装了GetAccessToken方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344WeChat.prototype.GetAccessToken = function() { var self = this let option = { url: &apos;https://api.weixin.qq.com/cgi-bin/token&apos;, qs: { grant_type: &apos;client_credential&apos;, appid: this.config.App_Id, secret: this.config.App_Secret }, method: &apos;GET&apos;, headers: { &quot;content-type&quot;: &quot;application/json&quot; } } return new Promise((resolve, reject) =&gt; { request(option, function(error, response, body) { console.log(error, body) var data = JSON.parse(body) if (error) { reject(error) } else { switch(data.errcode) { case 45009: console.log(&apos;token调用上限&apos;) reject(data) break case 0: self.accessToken = { access_token: data.access_token, expires_in: data.expires_in } console.log(&apos;当前access_token&apos;, JSON.stringify(self.accessToken)) // 定时重新获取access_token clearTimeout(this.getAccessTokenTimer) this.getAccessTokenTimer = setTimeout(() =&gt; { self.GetAccessToken() }, (data.expires_in - 60) * 1000 || 60000) resolve(data) break } } }) })} 并在express服务启动的时候调用GetAccessToken，调用成功后会依据 expires_in 起定时器重新获取。 123456var wechat = new WeChat(config)wechat.GetAccessToken().then(success =&gt; { console.log(&apos;初始化获取accessToken成功&apos;)}, failure =&gt; { console.log(&apos;初始化获取accessToken失败&apos;)}) 2018.10.17考虑到每次重启服务器都会调用GetAccessToken，会导致频繁调用。因此想到一个修改方法，将accessToken作为属性存在wechat对象中的同时，还将其写入到本地文件token.json中。这样服务器重启时，就可以先读取token.json文件中的access_token及expires_in，先判断是否过期，如果过期了，则直接进行access_token更新操作，否则计算出过期时间，用定时器控制在过期时间时进行access_token更新操作。","link":"/Nodejs开发微信公众号-获取access-token.html"},{"title":"Nodejs开发微信公众号--测试号配置篇","text":"微信公众号感觉入门是真的难啊，受权限的约束，个人开发者真的挺难走的，特别像博主这种主攻前端的人。由于迟迟没把域名备案办下来。先从测试号入手。 申请页面信息打开测试号申请页面，可以看到需要填写的内容。 首先要做的就是接口配置信息这部分内容了。 内网穿透一般我们会在本地进行开发，因此必须使用工具进行内网穿透，将一个公网域名穿透到本地内网。用NATAPP可以做到。使用方法很简单，这里不再赘述。 NodeJS服务器搭建我这边使用express生成器搭建服务。 12345678910// 全局安装生成器npm install express-generator -g// 生成项目，并指定模板引擎express --view=ejs wechat_expresscd wechat_express// 安装node依赖npm install// 启动set DEBUG=myapp:* &amp; npm start 新建一个配置文件config/index.js 12345const CONFIG = { port: &apos;4300&apos;, token: &apos;你的token&apos;}exports.CONFIG = CONFIG; 在app.js中指定端口 1app.set(&apos;port&apos;, config.port); 写路由，进行微信公众号的token验证 12345678910111213141516171819202122232425262728293031var express = require(&apos;express&apos;);var crypto = require(&apos;crypto&apos;);var config = require(&apos;../config/index&apos;).CONFIG;var router = express.Router();router.get(&apos;/&apos;,function(req,res){ console.log(req) //1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr var signature = req.query.signature,//微信加密签名 timestamp = req.query.timestamp,//时间戳 nonce = req.query.nonce,//随机数 echostr = req.query.echostr;//随机字符串 //2.将token、timestamp、nonce三个参数进行字典序排序 var array = [config.token,timestamp,nonce]; array.sort(); //3.将三个参数字符串拼接成一个字符串进行sha1加密 var tempStr = array.join(&apos;&apos;); const hashCode = crypto.createHash(&apos;sha1&apos;); //创建加密类型 var resultCode = hashCode.update(tempStr,&apos;utf8&apos;).digest(&apos;hex&apos;); //对传入的字符串进行加密 //4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 if(resultCode === signature){ res.send(echostr); }else{ res.send(&apos;mismatch&apos;); }});module.exports = router; 启动服务，并在测试号申请页面，填入URL和Token进行验证。验证成功后便可以继续下一步了。 JS接口安全域名暂时还未用到，填写URL所在域名即可。","link":"/Nodejs开发微信公众号-测试号配置篇.html"},{"title":"VSCode缩进方式转换","text":"前言首先要明确的是，一般我们推荐的是采用空格进行缩进，因为tab不是一个标准的东西，如果使用tab缩进，可能在不同的系统中表现有差异。我个人还是喜欢4空格缩进，所以对于某些2空格缩进的代码，我还是有必要去做下转换的。下面以2空格缩进转4空格缩进为例进行说明。 2空格缩进转4空格缩进方法第一步，查看并确认下我们当前的缩进方式。 可以看到，是以2空格作为缩进。 接着，我们把缩进转换为tab。 然后，我们再设置以tab为缩进方式，并指定数值为4（代表1个tab表现为4个空格，但它毕竟还是tab，不是标准的空格）。 最后我们把缩进转为空格，这样2空格就变为4空格了。 同理，4空格变为2空格也是类似的。","link":"/VSCode缩进方式转换.html"},{"title":"TortoiseGIT安装教程","text":"前言不知道各位有没有这种感觉，就我一个小白来讲，不管是写一个demo也好，亦或是准备搞一个自己的小项目来说，代码管理真的是太重要了。每当自己写得代码有问题想要回退时，或者某刻想要找到之前的代码记录时，我发觉自己真的需要一个代码管理工具了。 明确自己的需求现在的代码管理工具，主流无非是SVN（集中式）或者GIT（分布式）。从形式上来看，要么是命令行工具，要么是GUI工具。很多人在这里可能就迷茫了，选哪个？就我而言，我需要一个简单的，不需要特别深入学习原理，可视化的东西。所以我选择了TortoiseGIT。 下载安装https://tortoisegit.org/download/这个是下载的链接，根据自己的电脑情况来选择。我的电脑是64位，所以直接点64位下载了。 下载完成就接着安装了，前两步直接选next就行了。 接下来这个选择第一项就好，从字面意思看，它是针对windows做了优化了，所以没什么问题。 然后就是选择安装的位置了，这个看个人喜好，我习惯选D盘。 然后就下一步，安装。接着会打开配置向导，选择生成putty秘钥。生成过程需要移动鼠标。 把生成的私钥存储在计算机上，然后把公钥保存在GitHub的SSH keys中 生成了公钥和私钥后，还有一件事，就是加载private key 的key文件。在安装目录中找到pageant.ext，打开然后添加私钥。 然后通过setting是可以配置很多东西的，包括右键菜单，语言，等等。 如果遇到右键没有菜单的问题，那么请重启一下，应该就解决了吧！","link":"/TortoiseGIT安装教程.html"},{"title":"VMware安装CentOS7时遇到的黑屏问题解决方法","text":"问题背景上大学时一度以为自己不会跟linux搭上关系，然而走到部署服务器这一步还是离不开linux。默默开始学习linux吧。装好虚拟机准备开始安装CentOS7时，发现自己刚入坑就被难住了。点击安装直接黑屏。。。 解决方案在网上查阅后发现，有人遇到了和我一样的问题。原因是BIOS的Virtualization Technology设置被禁止了，需要进入BIOS将其设置为Enabled。（不同电脑进入BIOS的方法不尽相同，请网上查阅对应电脑型号的进入BIOS的方法，我的是Fn+F1） 设置成功后重启，再打开VMware安装CentOS7就可以顺利安装了。 看到这个界面后，感觉整个人都舒服了！^_^","link":"/VMware安装CentOS7时遇到的黑屏问题解决方法.html"},{"title":"WebSocket实现实时通讯（socket.io实现简版聊天室）","text":"最近一段时间了接触了一些websocket编程。这里记录一个简单的入门demo。该demo利用socket.io实现了一个简单的聊天应用。各位看官老爷，且接着看具体的实现方式。 准备工作本人主要是前端开发，会一点点nodejs。因此这个demo是基于socket.io.js实现的。 B/S服务端首先，我们在服务端安装socket.io 1npm install --save socket.io B/S客户端接着，在vue项目中安装socket.io-client 1npm install --save socket.io-client 思路聊天室最基本的功能应该有系统通知，聊天内容等。系统通知针对所有socket连接，即是全局广播；聊天内容则是除当前socket用户的非全局广播。还可能存在系统与某个用户的单独消息互动，这则是单播。本文先不涉及room的概念，高手莫怪。 实现方式socket服务端主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var http = require(&apos;http&apos;);var express = require(&apos;express&apos;);var app = express();var server = http.createServer(app)var io = require(&apos;socket.io&apos;)(server);server.listen(app.get(&apos;port&apos;), function() { console.log(&apos;Express server listening on port &apos; + app.get(&apos;port&apos;));});// 监听socket连接io.on(&apos;connection&apos;, function (socket) { // 当某用户连上聊天室socket服务时，给他打个招呼 sendToSingle(socket, { event: &apos;greet_from_server&apos;, data: `你好${socket.id}` }) // 对其他用户给出通知：某某某加入了聊天室 broadcastExceptSelf(socket, { event: &apos;new_user_join&apos;, data: { user: socket.id } }) // 监听用户发的聊天内容 socket.on(&apos;chat&apos;, function (data) { // 然后广播给其他用户：某某某说了什么 broadcastExceptSelf(socket, { event: &apos;new_chat_content&apos;, data: { user: socket.id, content: data } }) }); // 监听socket连接断开 socket.on(&apos;disconnect&apos;, (reason) =&gt; { // 广播给其他用户：某某某退出了聊天室 broadcastExceptSelf(socket, { event: &apos;someone_exit&apos;, data: { user: socket.id } }) });});// 给当前socket连接单独发消息function sendToSingle(socket, param) { socket.emit(&apos;singleMsg&apos;, param);}// 对所有socket连接发消息function broadcastAll(param) { io.emit(&apos;broadcastAll&apos;, param)}// 对除当前socket连接的其他所有socket连接发消息function broadcastExceptSelf(socket, param) { socket.broadcast.emit(&apos;broadcast&apos;, param);} socket客户端实现方式也比较简单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import io from &apos;socket.io-client&apos;;// 创建和管理socketcreateSocket() { let self = this this.socket = io(this.$store.state.config.API_ROOT); this.socket.on(&apos;connect&apos;, function(){ console.log(&apos;连上了&apos;) }); // 这里接收服务端发来的单独消息 this.socket.on(&apos;singleMsg&apos;, function(msg){ console.log(msg) switch (msg.event) { // 如来自服务端的问候，虽然这里没写什么，但是可以据此做一些页面上的效果 case &apos;greet_from_server&apos;: break default: break } }) // 目前还没用到，可拓展 this.socket.on(&apos;broadcastAll&apos;, function(msg){ console.log(msg) }) // 监听广播 this.socket.on(&apos;broadcast&apos;, function(msg){ console.log(msg) switch (msg.event) { // 新用户加入聊天室 case &apos;new_user_join&apos;: self.msgList.push({ time: new Date().toLocaleString(), user: &apos;系统通知&apos;, content: `用户 ${msg.data.user} 加入了聊天室......` }) break // 用户退出聊天室 case &apos;someone_exit&apos;: self.msgList.push({ time: new Date().toLocaleString(), user: &apos;系统通知&apos;, content: `用户 ${msg.data.user} 退出了聊天室......` }) break // 接收某用户的聊天内容 case &apos;new_chat_content&apos;: self.msgList.push({ time: new Date().toLocaleString(), user: msg.data.user, content: msg.data.content }) break default: break } }) this.socket.on(&apos;disconnect&apos;, function(){ console.log(&apos;连接断开了&apos;) });},// 监听输入框回车事件onInpuKeyDown(e) { console.log(e) if (e.keyCode == 13) { // 将输入的聊天内容推送给服务端 this.socket.emit(&apos;chat&apos;, e.target.value) this.msgList.push({ time: new Date().toLocaleString(), user: &apos;我说&apos;, content: e.target.value }) this.newMsg = &apos;&apos; }} 我们用打开多个窗口的方式模拟多个用户的加入，我这里开了三个窗口，最后的效果大概是这样的。 用户1看到用户2和用户3谈到了很晚的事情 切到了当前用户2的界面 切到了当前用户3的界面 用户3退出了聊天室，在用户2的界面上可以看到推送的系统通知，然后用户2说了一句话也退出了 用户1看到用户2和用户3的退出情况","link":"/WebSocket实现实时通讯（socket-io实现简版聊天室）.html"},{"title":"express搭建简单的后台服务器（基础篇）","text":"本文简单对express的一些重要基础知识做一下记录，以加深自己对express基础的了解。 不得不说的路由作为一个后台服务器，你必须要处理来自客户端的各种请求。这个时候，就要先定义各种请求的处理器，也就是路由。引用express官方的解释。 路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 路由方法路由method有很多种，我们常见的有POST，GET两种。基本的写法如下。这里的路由地址可以是字符串，也可以是字符串模式或者正则表达式，req是请求对象，res是响应对象，next()负责将控制权交给下一个中间件。中间件的概念后面会提到。 1234567891011// GET method routeapp.get(&apos;/&apos;, function (req, res, next) { res.send(&apos;GET request to the homepage&apos;); next();});// POST method routeapp.post(&apos;/&apos;, function (req, res, next) { res.send(&apos;POST request to the homepage&apos;); next();}); 还有一种不区分请求方式的写法，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。 1234app.all(&apos;/secret&apos;, function (req, res, next) { console.log(&apos;Accessing the secret section ...&apos;); next(); // pass control to the next handler}); app.route()通过这个方法创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。书写格式如下： 12345678910app.route(&apos;/book&apos;) .get(function(req, res) { res.send(&apos;Get a random book&apos;); }) .post(function(req, res) { res.send(&apos;Add a book&apos;); }) .put(function(req, res) { res.send(&apos;Update the book&apos;); }); express.Router可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统。这样我们就可以在一个文件中专门做路由处理，而在app.js中use这个中间件。例如我们在一个routes.js文件中这样使用。 123456789// routes.js文件var express = require(&apos;express&apos;);var router = express.Router();// 定义网站主页的路由router.get(&apos;/&apos;, function(req, res) { res.send(&apos;home page&apos;);});// 这里把中间件导出，供app.js使用module.exports = router; app.js中这样使用： 1234567var router = require(&apos;./router&apos;);// 其他处理逻辑代码.........// 最后use路由中间件app.use(&apos;/&apos;, router); 静态文件使用静态文件服务express的静态文件可以放在public文件夹中。通过Express内置的express.static可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。 1app.use(express.static(&apos;public&apos;)); 然后就可以访问public中的静态资源了。 1http://localhost:3000/images/avatar.jpg 多个静态资源文件夹如果静态资源存放在多个目录下面，我们可以多次调用 express.static 中间件。例如： 12app.use(express.static(&apos;public&apos;));app.use(express.static(&apos;assets&apos;)); 挂在虚拟目录下1app.use(&apos;/resourse&apos;, express.static(&apos;public&apos;)); 那么访问的方式就是 1http://localhost:3000/resourse/images/avatar.jpg 中间件定义什么叫中间件，引用官方的解释就是： 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。 中间件可以做的事情（1）执行任何代码。（2）修改请求和响应对象。（3）终结请求-响应循环。（4）调用堆栈中的下一个中间件。 中间件分类应用级中间件应用级中间件绑定到app对象，使用 app.use() 和 app.METHOD()。其中METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。 1234567891011121314// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) { console.log(&apos;Time:&apos;, Date.now()); next();});// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use(&apos;/user/:id&apos;, function (req, res, next) { console.log(&apos;Request Type:&apos;, req.method); next();});// app.get// app.post// ... 路由级中间件就是上文中说到的 express.Router()，是由app.use来调用。 错误处理中间件 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 1234app.use(function(err, req, res, next) { console.error(err.stack); res.status(500).send(&apos;Something broke!&apos;);}); 内置中间件express.static 是 Express 唯一内置的中间件。它负责在 Express 应用中托管静态资源。一般用法如下： 1app.use(express.static(path.join(__dirname, &apos;public&apos;), option)); express.static可以传option参数，option具体内容如下： 第三方中间件第三方提供的中间件，如 cookie-parser等。也是由app.use加载。 123var cookieParser = require(&apos;cookie-parser&apos;);// 加载用于解析 cookie 的中间件app.use(cookieParser());","link":"/express搭建简单的后台服务器（基础篇）.html"},{"title":"express搭建简单的后台服务器（入门篇）","text":"前言之前一段时间，工作之余我还比较闲。我就用Angular做了一个前端小demo，后台服务器就简单用express搭了一下。代码都是在公司写的，不能带回来。很久没关注，很多东西都忘记了。今天想重新温习一下，把一些重要的细节记下来。先从后台搭起。 安装express创建一个文件夹，在文件夹下运行命令行工具，先生成package.json。 1npm init 创建完毕后，安装express。 1npm install express --save 安装完，发现还是有点懵，这要从0开始写有点慢啊。还是找个脚手架吧。 安装Express 应用生成器运行这个命令装一下Express 应用生成器。 1npm install express-generator -g 然后创建一个应用，并安装依赖。 123express myappcd myappnpm install 启动express服务器运行启动命令，就可以打开localhost:3000查看效果了。 1npm start","link":"/express搭建简单的后台服务器（入门篇）.html"},{"title":"gulp入门基础","text":"gulp是前端开发过程中经常要用到的工具，非常值得花时间去掌握。利用gulp，我们可以使产品流程脚本化，节约大量的时间，有条不紊地进行业务开发。本文简单讲一下入门gulp需要掌握的东西。 安装gulp首先，我们需要在全局安装gulp。 1npm install -g gulp 然后，我们切到项目根目录，在项目中也进行gulp的安装，表明项目对gulp的依赖。 1npm install --save-dev gulp 接着，我们在项目根目录里新建一个gulpfile.js文件，这个是gulp的配置文件。 使用gulp学习gulp的使用，我们需要先学习好常用的语法。 gulp.src(globs[, options])输出符合所匹配模式（glob）的文件。将返回一个stream，可以被piped传递到其他gulp插件中继续操作。 gulp.task(name[, deps], fn)定义一个gulp任务，name是任务名称。[, deps]是任务依赖。fn是任务回调函数。（1）任务依赖的形式可以是： 12345678gulp.task(&apos;two&apos;, [&apos;one&apos;], function() { // &apos;one&apos; 完成后});gulp.task(&apos;one&apos;, function(cb) { // cb(); // return stream; // return promise;}); 其中one应该使用一个callback，或者返回一个promise 或stream，表明依赖的任务完成了。（2）回调函数体会是这种形式： 1gulp.src().pipe(someplugin()) gulp.dest(path[, options])将pipe进来的stream输出文件到指定的路径下,如： 123gulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) gulp.watchgulp.watch(glob [, opts], tasks)监视文件，并且在文件发生改动时候执行一个或者多个task。监听change事件实现。 1234var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);watcher.on(&apos;change&apos;, function(event) { console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);}); gulp.watch(glob [, opts, cb])监视文件，并且在文件发生改动时候执行回调函数cb。 123gulp.watch(&apos;js/**/*.js&apos;, function(event) { console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);}); gulp.rungulp模块的run方法，表示要执行的任务。可能会使用单个参数的形式传递多个任务。任务是尽可能多的并行执行，并且可能不会按照指定的顺序执行。当不需要指定执行顺序时，可以适当使用。 1gulp.run(&apos;task1&apos;,&apos;task2&apos;,&apos;task3&apos;); gulp使用技巧替代任务依赖写法我们需要让任务有秩序地执行，那么可以使用第三方插件gulp-sequence。 12// 如果使用gulp-sequence，就不需要附加任务依赖了。数组内的任务平行执行，数组外的按顺序执行。所以这里是svgstore、uglify-js并行执行，然后执行public任务。gulp.task(&apos;sequence1&apos;, gulpSequence([&apos;svgstore&apos;, &apos;uglify-js&apos;], &apos;public&apos;)); 修复gulp.watch方法只执行一次的问题利用gulp-watch，gulp-batch两个工具，用法如下： 123456// 当监听到svgs目录下任意svg文件变动时，执行svgstore任务gulp.task(&apos;watch&apos;, function() { watch(&apos;./assets/svgs/*.svg&apos;, batch(function(events, done) { gulp.start(&apos;svgstore&apos;, done); }));});","link":"/gulp入门基础.html"},{"title":"hexo+github打造个人博客系列之Coding Pages去广告","text":"尴尬的广告大家应该可以看到，在第一次以自定义域名访问Coding Pages时，会有一个跳转广告。是不是很尴尬？经查阅官方说明，得知原因。 银牌会员的 Coding Pages 在访问时默认会先加载 Pages 跳转页，您可选择在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，然后勾选下方的「已放置 Hosted by Coding Pages」选项，通过审核后您的 Pages 将不会显示跳转页。请务必将「Hosted by Coding Pages」持续保留在网站首页，撤掉后跳转页会再次出现。 本来以为这个广告是去不掉了，看到这里我觉得Coding还算人性化。最多就是在首页底部声明一下「Hosted by Coding Pages」，总比每个人第一次一打开你的博客就是广告要舒服。 解决方案官方已经提供了文字或者图片两种策略。我个人偏向于加文字声明。 1&lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 找到footer.swig文件，将这段代码加在自己觉得合适的位置就好，保存一下，看下效果。如果正常渲染了，就部署一下，然后在Coding Pages服务中提交审核申请。 Hosted by Coding Pages 已提交审核，我们会在两个工作日内为您处理。 然后就等待审核结束就OK。","link":"/hexo+github打造个人博客系列之Coding Pages去广告.html"},{"title":"hexo+github打造个人博客系列之Coding托管（实现github+coding双线部署）","text":"背景从网上搜索的结果来看，很多人都认为github博客在国内的seo情况不太好，不被百度爬虫所青睐。一个比较好的方案是，同时将hexo博客部署到github和Coding上。所以我也想试一下，顺便了解一下Coding这个代码托管平台。 注册Coding点击Coding官网，完成注册。 注册完成后，按照提示绑定一下手机和邮箱，就成为所谓的银牌会员了，会提升空间大小，方便后续使用。 创建一个项目按照下图指示，创建一个公开项目，类似于github的仓库。 设置ssh秘钥查询公钥与github是一样的，使用服务需要验证ssh秘钥。首先在计算机对应的文件夹中找到公钥。一般是这样一个目录。以前没有生成过ssh秘钥的，需要查阅一下如何生成ssh秘钥。 设置公钥将公钥的内容存储到Coding的账户中。 验证SSH服务配置完成后，验证一下是否可以ssh连接coding.net，在git bash中敲命令 1ssh -T git@git.coding.net 如果界面显示这样的信息，那么证明ssh连接是OK的。 Hexo配置然后配置hexo，在deploy字段下新增一个git仓库，repo是coding项目对应的ssh url 配置完后，运行deploy部署命令，就可以在coding仓库中看到代码了。 1hexo deploy 使用Coding Pages服务Coding也提供了类似github的Pages服务，按照流程填写一下，就可以开启Pages服务了。 启用Pages服务后，就可以通过Coding提供的二级域名访问博客页面了。但是刚启动，好像看到了很多403，404错误。扎心了老铁，还得慢慢排错啊。。。 排错查阅了各个资源文件的获取情况，发现是子目录不对造成的。 可以看到，部署在Coding该项目下的资源都是在hexo-blog子目录下的，而这里http访问的url是没有hexo-blog的。所以造成了访问403，404各种错误。那么如何解决这个问题呢？那就是将Coding pages的地址作为一个CNAME解析到我的域名下。 添加CNAME解析来到阿里云的控制台，找到域名解析。添加CNAME解析。将原来的指向github主机的A记录切换到海外线路。添加pages.coding.me的CNAME记录。 Coding Pages添加自定义域名完成上一步后，就可以在Coding Pages添加自定义域名了。 这个时候再点击自己的域名，已经是正常访问了，也没有页面错乱，报错的现象了，大功告成！ 至此，我们也完成了github+coding双线部署！","link":"/hexo+github打造个人博客系列之Coding托管（实现github+coding双线部署）.html"},{"title":"hexo+github打造个人博客系列之主题和部署","text":"这篇文章主要记录基于hexo实现博客中一些复杂功能点的相关操作细节，为自己做一个笔记，也为后来者提供一些思路。 hexo应用主题我也不知道哪种是最好的，看大家用得比较多的就是Next，yilia，casper等。我自己选择了Next主题。Next坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性，界面上简洁大方，给我眼前一亮的感觉。 安装next主题点击Next主题中文网，克隆最新版本或者下载最新稳定版本。我选择下载了稳定版本。 在hexo中使用next主题在站点配置_config.yml中配置主题 1theme: next 保存一下，再打开localhost:4000就可以看到效果了。终于脱坑了，不再是与亿万人相同的初始化界面了。 利用hexo将博客部署到github空间上文中提到过，github为每个注册用户都提供了免费的二级域名与空间。所以我们可以轻松让博客上线。步骤也比较简单。 安装 hexo-deployer-git1npm install hexo-deployer-git --save 修改deploy配置然后在站点配置中修改deploy配置 这是我的配置，repo是对应仓库的地址，branch我是放在master分支上的。 完成部署保存后运行 123hexo cleanhexo generatehexo deploy 部署完成后，稍等片刻，然后打开对应域名，就可以访问到自己的博客了。 不知道域名的请打开仓库的设置页面，翻到下面就能看到。 好了，基本上就大功告成了。","link":"/hexo+github打造个人博客系列之主题和部署.html"},{"title":"hexo+github打造个人博客系列之小技巧","text":"这篇博客记录一下hexo+github打造个人博客过程想到的一些小技巧，分享给大家。 去除valine的Powered Byvaline评论系统自带Powered By，如下图所示。 我喜欢简洁一点，所以想去掉这个提示。查看Elements可以看到这个div，那么我只要移除这个div下的所有子节点，就可以去掉这个Powered By了。修改对应的文件valine.swig，直接上代码： 1234567891011new Valine({...pageSize:&apos;{{ theme.valine.pageSize }}&apos; || 10,});//新增以下代码即可，可以移除.info下所有子节点。var infoEle = document.querySelector(&apos;#comments .info&apos;);if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0){ infoEle.childNodes.forEach(function(item) { item.parentNode.removeChild(item); });} 修改后效果：","link":"/hexo+github打造个人博客系列之小技巧.html"},{"title":"hexo+github打造个人博客系列之数据统计与分析","text":"看到各种第三方服务，我就想折腾一下。本文简单说一下如何给自己的博客加上站点统计功能。 百度统计登录百度统计打开百度统计，输入百度账号密码即可。 添加网站来到个人中心的“管理”模块，点击“新增网站”按钮，填写博客网站的信息。 获取统计ID点击左侧菜单的“代码获取”，然后找到?后的ID（截图中被马赛克覆盖的部分），复制到粘贴板，供hexo中配置使用。每个网站对应的统计ID都不同，不要复制别人的，否则就没什么意义了。 修改主题配置将刚才复制的ID赋值给Next主题配置中的baidu_analytics字段 部署和查看数据保存修改后，再次部署博客。 1hexo deploy 然后百度统计就可以统计到你的站点信息了。 CNZZ统计注册友盟账号打开友盟注册页面。注册完毕后点击“网站统计”进入站点管理页面。 添加站点点击右侧的“添加站点”按钮，填写博客站点信息，完成添加。 获取CNZZ统计ID点击“统计代码”，可以查看到你的站点对应的统计ID。 复制这个ID，以便后面配置Hexo使用。 修改Hexo中主题配置修改next主题配置里面的cnzz_siteid字段，值为刚才复制的ID。修改完毕后，重新部署应用即可在cnzz我的站点中查看统计报表了。这里就能发现，CNZZ与百度统计是同一个套路，其他的第三方统计也是类似，不再赘述。","link":"/hexo+github打造个人博客系列之数据统计与分析.html"},{"title":"hexo+github打造个人博客系列之评论系统","text":"前言一个博客怎么能没有评论互动，那也太枯燥无味了吧，简直反人类。最近也是刚学会一点皮毛，把hexo博客搭了起来。于是就想折腾一下评论系统。网上查了下现在第三方评论系统的现状：多说已经关了，网易云跟帖8月1号关闭，畅言要备案，Disqus被墙。呵呵哒，那么还剩下什么？费了一番功夫搜索了很多，选出了几款我比较满意的评论系统：来必力（LiveRe），Valine，gitment。下面详细说一下。 来必力这个怎么玩呢？首先还是注册账号。我发现hexo玩起来注册了好多账号啊！登录进去后点击右上角头像，进入个人管理页面。然后就是添加应用信息，下面是已经添加成功的页面了。 来必力还有个评论提醒的功能，人性化啊。 最关键的一步，点击“代码管理”找到uid，复制下来。 最后来到Next主题配置，修改_config.yml中的livere_uid，将复制的uid粘贴即可。然后部署一下，OK。 页面效果如下，支持多种第三方账号登录，看起来很感人。 经过测试，来必力好像不是很友好，发起评论直接报了个504错误（504错误是（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。）。蛋疼么？我在想是不是我配置问题，于是我去到别人的hexo博客上评论，也报了同样错误，最后又试了手机，都没法评论，这还怎么玩，发到朋友圈，都没法评论，还怎么装逼？（手动滑稽）。 默默把livere_uid配置为空了。 Valine开始折腾Valine。Valine 是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 注册Leancloud打开Leancloud，注册登录后，进入个人页面，创建应用，选择开发版就OK。 创建完成后，点击应用右上方的设置按钮，进入设置页面。在应用Key可以查看App ID，App Key，用于在页面上new Valine时使用。 在安全中心，填写Web安全域名，如https://cumtrobin.github.io/，防止别人盗用你的服务器资源。 在存储-数据中创建Class ‘Comment’，用作评论的数据库表。 回到Next主题配置，修改valine相关配置 部署后就可以看到效果了，评论功能终于都可以正常使用了。 gitment最后再折腾一下gitment。引用一下作者的话。 Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 注册 OAuth Application打开注册页面完成注册 配置注册成功后会得到Client ID和Client Secret，然后开始配置Next 部署部署一下就可以看到效果了。 如果想要展示多个评论系统，需要改布局，需要了解的可以留言讨论。","link":"/hexo+github打造个人博客系列之评论系统.html"},{"title":"hexo助小白打造个人博客之入门篇","text":"我一直想拥有一个个人的技术博客，苦恼不知如何开始。作为一个小白，还是从最简单的入手为好，在多方查找资料后，决定基于github+hexo打造一个简单的个人博客。下面我简单记录下过程。 为什么选择github+hexo?github为每个注册用户都提供了免费的二级域名与空间，给博客小白提供了初期建立博客的实验环境，非常人性化。而hexo作为当前一个非常流行的博客框架，快速、简洁且高效。hexo 基于nodejs，非常适合前端开发者，很快可以入手。而且支持时下流行的 markdown（或其他渲染引擎）解析文章生成静态网页，文章编写会非常简单快速。 如何建立github blog的雏形？在github上建立一个blog仓库，仓库信息简单填写即可。 进入仓库设置页面，填写一些必要的信息。 这里把仓库名称先填一下 接下来翻到下面，选择master分支，选择一个主题来发布博客页面。然后就可以通过提供的网址来访问到自己的博客了。 如何修改我的博客页面呢？初始生成的页面是基于README.md内容的。所以你可以修改这个文件的内容来观察页面改动的效果。 想要做更复杂的页面就可以用到博客框架hexo或者官方推荐的jekyll。这里我自己选用的是hexo。 利用hexo打造更生动的博客程序下载安装hexo cli工具1npm install -g hexo-cli 安装 Hexo 完成后，执行下列命令，Hexo 会在指定文件夹中新建所需要的文件。123hexo init myblogcd myblognpm install Hexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用。1npm install hexo-server --save 安装好服务器模块后，运行这个命令来生成静态文件。12hexo generate//或者 hexo g 运行启动服务器的命令，浏览器打开localhost:4000查看hexo博客页面效果1hexo server 好了，第一步算是大功告成了。想要做更深入的了解，请关注我的后续文章。","link":"/hexo助小白打造个人博客之入门篇.html"},{"title":"jdk下载和安装简明教程","text":"最近搞了一下angular，打包了一个demo后，想要放在服务器上看看效果，于是我就想到了tomcat。而安装tomcat又需要依赖jre或者jdk，那么我就下载jdk安装一下吧。之前在学校也是学过java，工作后一直没怎么用，感觉忘得差不多了，这里可以简单捋一捋。 下载jdk文件首先打开jdk下载地址，选择你要下载的jdk版本，这里我选择了windows64位的jdk9版本（大家根据自己的需求来选择）。 开始安装jdk整个安装过程都是比较简单的，基本上就是下一步。 这里可以根据个人喜好选择一下安装的路径。 接下来会弹出一个jre的安装提示，直接安装即可。 配置环境变量右键点击‘计算机’，选择‘属性’，再点击‘高级系统设置’，打开‘环境变量’。 新建JAVA_HOME变量在‘系统变量’处点击‘新建’，变量名为JAVA_HOME，变量值为C:\\Program Files\\Java\\jdk-9.0.4注：这里的变量值是你安装jdk所在的目录路径。 修改Path变量修改‘Path’变量的值，观察当前值最后是否有分号；如果有，直接在后面追加%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;如果没有，先追加一个分号; 再追加上面的值。 新建CLASSPATH变量在‘系统变量’处点击‘新建’，变量名为CLASSPATH，变量值为.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 至此，环境变量配置就完成了。下面可以进行测试，观察是否安装有效。 测试安装有效性测试java命令在任意一个目录下打开cmd命令行，输入java -version 测试javac命令在任意一个目录下打开cmd命令行，输入javac -version 能输出以上信息，基本上就表示安装成功了。那么我们就可以做后续的事情了。","link":"/jdk下载和安装简明教程.html"},{"title":"linux个人学习过程中常用命令及问题记录","text":"我是linux技术盲，这里记录一下自己在学习linux过程中敲的命令以及遇到的各种问题，脚踏实地一步一步学好linux。 yum install setuptool最小化的linux系统（centos\\redhat）默认都是没有安装setup图形小工具的，需要自行安装。 yum install ntsysv安装系统服务（设置系统的各种服务） yum install system-config-network-tui网络服务（敲了命令后提示No Package system-config-network-tui available，这里先记录一下，后面研究） yum install system-config-securitylevel-tuiyum install -y iptablesCentOS7默认的防火墙不是iptables，而是firewalle。这里安装iptables。 Xshell 5如何连接本地虚拟机参考教程 mv命令mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。http://man.linuxde.net/mv vi命令vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。http://man.linuxde.net/vi 没有eth0解决方案https://www.cnblogs.com/feixiangtk/p/6819118.html根据这篇文章指导，解决了xshell无法连接centos7的问题，感谢！ pwd命令pwd命令以绝对路径的方式显示用户当前工作目录。 mkdir命令mkdir命令用来创建目录。 chmod命令chmod命令用来变更文件或目录的权限。 touch命令touch命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。 xshell秘钥登录教程https://www.linuxidc.com/Linux/2016-06/132268.htm 桥接 NAT Host-only三者的区别https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html centos7无法安装npm和nodejs解决方案http://blog.csdn.net/tanga842428/article/details/73277739","link":"/linux个人学习过程中常用命令及问题记录.html"},{"title":"sea.js的同步魔法","text":"前些时间也是想写点关于CMD模块规范的文字，以便帮助自己理解。今天看到一篇知乎回答，算是给了我一点启发。 同步写法却不阻塞？先上一个sea.js很经典的模块写法： 1234567// 定义一个模块define(function(require, exports, module) { // 加载jquery模块 var $ = require('jquery'); // 直接使用模块里的方法 $('#header').hide();}); 按道理加载模块，就是需要等jquery.js加载完毕才能使用，应该是一个异步的过程，为什么可以写成同步的形式呢？这是用了什么黑科技？ 原来作者玉伯大佬用了一个小魔法来“欺骗”我们。而卢勃大神在知乎给了一个很精彩的解释，这里直接分享下： 也就是说，require.js和sea.js都是在执行模块前预加载了依赖的模块，并没有比require.js显得更“懒加载”，只是所依赖模块的代码执行时机不同。require.js加载时执行，而sea.js是使用时执行。 其实从代码的写法也看得出来，require.js的依赖模块在加载后便有了执行结果，并作为回调函数的实参传入。 reuiqre.js写法： 1234// 加载完jquery.js后，得到的执行结果$作为参数传入了回调函数define(['jquery'], function($) { $('#header').hide();}); sea.js写法： 1234567// 预加载了jquery.jsdefine(function(require, exports, module) { // 执行jquery.js模块，并得到结果赋值给$ var $ = require('jquery'); // 调用jquery.js模块提供的方法 $('#header').hide();}); 从这一点上来看，两者在性能上并没有太多差异。因为最影响页面渲染速度的当然是资源的加载速度，既然都是预加载，那么加载模块资源的耗时是一样的（网络情况相同时）。 而模块代码的执行时机并没有那么影响性能（除非你的模块太大），现在的js引擎如V8引擎足够强，没什么压力。 懒加载是否存在？懒加载是存在的。我刚才说的sea.js并没有比require.js更显得“懒加载”是指模块加载的时机上两者是一致的，都是预先加载，而不是说不能懒加载。 比如说，有一个模块，页面渲染时，我不需要加载使用，但是在做了某种交互时（比如点了按钮），才需要加载使用，这个时候“懒加载”的作用就体现了。下面以require.js举个实例： 123456789101112131415161718192021require.config({ baseUrl: './assets/js/', paths: { modulea: 'module-a', moduleb: 'module-b' }})require([\"modulea\"], function(modulea) { var btnNode = document.querySelector('#btn-load'); var node1 = document.createElement('span'); node1.innerText = '模块A已经加载！' btnNode.insertAdjacentElement('beforebegin', node1) btnNode.addEventListener('click', function() { require([\"moduleb\"], function(moduleb) { var node2 = document.createElement('span'); node2.innerText = '模块B已经加载！' btnNode.insertAdjacentElement('afterend', node2) }); })}); 页面渲染时只加载模块A 点击按钮后加载模块B 总结虽然AMD和CMD两种思想有一些差异，但都不失为一种优秀的模块化方案，为大佬们打call！","link":"/sea-js的同步魔法.html"},{"title":"ng-zorro使用过程中的一些笔记","text":"今天开始学习NG-ZORRO这个UI框架，过程中遇到了许多问题，这里把一些问题记录下来，方便后续查阅。NG-ZORRO由阿里大神们开源，给angular开发者提供了极大的便利。 改变icon图标的大小我试图通过改变width属性来改变图标的大小，通过background来改变颜色，最后才发现通过::before伪元素构造的图标其实是文字内容，因而其大小需要通过font-size来控制，而颜色则是由color来控制。知道真相的我眼泪掉下来。 12font-size: 24px;color: rgba(245, 245, 245, 0.6); 使用nz-button时，prod环境打包报错1&lt;button nz-button [nzType]=&quot;primary&quot;&gt; 在login组件中使用nz-button后，打包脚本执行到build:prod时报错，报错信息如下： 1ERROR in ng:///G:/projects/angular/my-app/src/app/login/login.component.html (9,3): Property &apos;primary&apos; does not exist on type &apos;LoginComponent&apos; 经过分析发现，可能是primary被当成这个组件的属性处理了，而我没有在组件中定义这个属性，所以报错，于是把它改成字符串试试。 1&lt;button nz-button [nzType]=&quot;&apos;primary&apos;&quot;&gt; 打包时间接近8分钟使用了nz-zorro后，打包竟然长达8分钟，而打包后的包的大小与之前一致。我相信这不是ng-zorro的问题，可能是我的webpack配置出现了问题。我之前使用的angular版本是4.2的，安装ng-zorro后报了个警告，于是我升级angular/core等版本到4.4，不知道是不是这些问题引起的，具体原因还没找到。这里先挖个坑。 12// 这一步等待时间超长，接近8分钟91% additional asset processing","link":"/ng-zorro使用过程中的一些笔记.html"},{"title":"ubuntu系统下sudo权限用户安装nodejs和nginx","text":"前言为了支撑公司某 ios app 上线，今天做了个隐私政策 h5 页面并上线，顺手体验了一把 ubuntu系统的 sudo 权限。本来想用 nodejs 的 express 框架搭个简单的静态资源托管服务，然后用 nginx 做下反向代理。但是在安装 express-generator 时遇到点问题，可能 sudo 权限玩得不够熟练，跟 root 用户还是有很大区别的。本文简单说下自己在 ubuntu 系统下 sudo 权限用户安装 nodejs 和 nginx 的过程。 安装nodejs下载安装包话不多说，直接上nodejs下载链接。 解压和软连接下载到的 nodejs 包是一个 .tar.xz 格式的包，解压命令如下： 1tar -xvf node-v10.15.3-linux-x64.tar.xz 为了让 node 和 npm 命令行全局可用，我采用了软连接的方式 12sudo ln -s /home/devadmin/frontend/download/node/bin/node /usr/local/bin/nodesudo ln -s /home/devadmin/frontend/download/node/bin/npm /usr/local/bin/npm 然后就可以舒服地使用 node 和 npm 命令行了。 设置npm代理为了提升 npm install 的速度和体验，我还用到了 npm 代理。 1npm config set registry https://registry.npm.taobao.org 这样 nodejs 就算安装完成了。 安装nginx安装 nginx 时采用的是 apt-get 的下载方式 1sudo apt-get install nginx nginx关注点安装后要知道的几点是： 配置文件所在目录 1/etc/nginx/ 静态资源所在目录 1/usr/share/nginx/ nginx主程序 1/usr/sbin/nginx nginx日志所在目录 1/var/log/nginx/ 配置文件的坑配置文件 nginx.conf 有个坑，需要把配置中的两行注释掉才有效。 12# include /etc/nginx/conf.d/*.conf;# include /etc/nginx/sites-enabled/*; 其他的坑遇到了 xftp 无法上传文件的情况，一般是文件夹权限不够，可以提高权限，然后再尝试。 1sudo chmod 777 dirname","link":"/ubuntu系统下sudo权限用户安装nodejs和nginx.html"},{"title":"vue-router基础内容","text":"vue-router是vue官方指定的路由库，让我们来撸一遍vue-router的基本概念吧！ 安装我是以直接下载的方式来引入vue-router的。 1&lt;script src=\"./lib/vue-router.js\"&gt;&lt;/script&gt; 使用vue-router定义路由12345678const routes = [ // 这里定义一个最基础的路由 { path: '/b', component: ComponentB } // 动态路由 { path: '/user/:id', component: User } // 命名路由 { path: '/user/:id', name: user, component: User }]; 创建 router 实例123const router = new VueRouter({ routes // （缩写）相当于 routes: routes}) vue实例注入路由通过 router 配置参数注入路由。 12345var app = new Vue({ el: '#app', router: router, ......}) 通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由。 使用路由出口123&lt;!-- 路由出口，与angular的router-outlet类似 --&gt;&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 路由跳转router-link通过router-link组件，我们可以进行路由的跳转。to属性的写法很多，请参考router-link。 12&lt;router-link to=\"/b\"&gt;Component B&lt;/router-link&gt;&lt;router-link :to=\"{ path: '/c' }\"&gt;Component C&lt;/router-link&gt; 编程式路由router.push(location, onComplete?, onAbort?)该方法的参数location可以是一个字符串路径，或者一个描述地址的对象。用法如下： 1234router.push('b');router.push({path: 'b'})router.push({path: 'user/1'})router.push({name: 'user', params: {id: 1}}) router.replace(location, onComplete?, onAbort?)跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 1router.replace(...) ps：你也可以在router-link使用replace。 1&lt;router-link :to=\"...\" replace&gt; router.go(n)类似 window.history.go(n)。是history回退和前进的操作。 了解了上述几个点后，你基本上可以完成基本的路由功能了。 嵌套路由一个组件内部也可以有路由视图router-view。 1234&lt;div&gt; &lt;p&gt;FatherComponent Content&lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 于此同时需要在路由定义处添加children属性。也是类似嵌套的写法。 1234567{ path: '/father', component: FatherComponent, children: [ { path: 'child', component: ChildComponent } ]} 命名视图当我们的布局是由几部分组成时，并且我们希望每一部分都有自己的路由，那么此时就不是嵌套路由了，而是多路由视图，这个时候我们就需要用到命名视图了。 123&lt;router-view class=\"view one\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view two\" name=\"a\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view three\" name=\"b\"&gt;&lt;/router-view&gt; 而在定义路由的时候也要对应好。 123456789101112const router = new VueRouter({ routes: [ { path: '/', components: { default: Foo, a: Bar, b: Baz } } ]}) 用watch监测路由很多时候我们可能需要监测路由变化，那么需要在watch中监测’$route’，方法大体是’$route’ (to, from) {your code} 12345678watch: { '$route': function (to, from) { this.fromRoute = from.path; this.toRoute = to.path; // 可以根据情况做一些后续的逻辑处理 ...... }} 路由重定向重定向的意思就是本来是要跳路由A的，但是定向到B。写法如下： 123456789101112routes: [ { path: '/b', component: ComponentB }, // redirect为path的形式 { path: '/a', redirect: '/b' }, // redirect为name的形式 { path: '/a', redirect: { name: 'compB'} }, // 甚至是一个方法，动态返回重定向目标，这样我感觉都可以做路由守卫了。 { path: '/a', redirect: to =&gt; { // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 }}] 路由别名123routes: [ { path: '/a', component: A, alias: '/b' }] alias的意思是别名，通俗讲，你大名是张三，别人叫你阿三，你也答应了，阿三就是你的别名。反映到路由上就是说，b是a的别名，那我输入路由b，地址栏会显示b，但也会映射到A组件；如果输入a，那地址栏就还是a，组件也是A，没什么变化。 向路由组件传递props在组件中使用 $route 会使之与其对应路由形成高度耦合，我们可以使用props的形式来重新定义。这样id就会作为一个prop属性，用来接收传递的数据。 123456789// 路由定义routes: [ { name:'employee', path: '/employee/:id', component: Employee, props: true}]// 组件定义const Employee = Vue.component('Employee', { props: ['id'], template: '&lt;p&gt;I am worker {{id}}&lt;/p&gt;'}); 路由守卫通过跳转或取消的方式守卫路由。 全局守卫使用router.beforeEach注册全局的路由守卫： 123456789router.beforeEach(function(to, from, next) { console.log('GLOBAL_beforeEach'); if (to.path === '/my') { next(false); alert('You are not registered...'); } else { next(); }}); next：一定要调用该方法来 resolve 这个钩子 next(): 进行管道中的下一个钩子。 next(false): 中断当前的导航。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。也可以传params的。 路由独享的守卫利用beforeEnter钩子实现。 1234567891011const routes = [ { name:'user', path: '/user/:id', component: User, beforeEnter: function (to, from, next) { console.log('ROUTE_beforeEnter'); next(false); } }] 组件内的守卫可以利用beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave几个钩子来定义守卫。 beforeRouteEnter用于拦截进入组件的情形。 beforeRouteUpdate用于当前路由改变，但是该组件被复用的情况，如/user/1 和 /user/2 之间跳转的时候。 beforeRouteLeave用于拦截离开组件的情形。 路由transitionrouter-view是基本的动态组件，所以我们可以用 transition组件给它添加一些过渡效果。 123&lt;transition name=\"slide\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 路由切换时记住滚动的位置创建 Router 实例时，指定scrollBehavior属性。 1234567891011const router = new VueRouter({ routes: [...], scrollBehavior (to, from, savedPosition) { // 第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的前进/后退 按钮触发) 时才可用。 if (savedPosition) { return savedPosition } else { return { x: 0, y: 0 } } }}) 更多功能实现请参考vue-router文档。","link":"/vue-router基础内容.html"},{"title":"vue作用域插槽，你真的懂了吗","text":"前言在网上搜了很多关于作用域插槽的解释，感觉没有写得很具体的吧，我认为应该对组件化有很深的理解才会触及到这个问题吧，这里也分享下我自己对于slot-scope的一点理解。 slot大家看看文档都懂了，无非就是在子组件中挖个坑，坑里面放什么东西由父组件决定。 123456789101112// 子组件&lt;template&gt; &lt;slot&gt;来啊，我这里挖了个坑&lt;/slot&gt;&lt;/template&gt;// 父组件&lt;template&gt; &lt;child&gt; &lt;!-- 传入子组件的自定义内容，会填入到子组件的slot插槽中 --&gt; &lt;span&gt;我在这放个span，乐意的话，放个组件都行&lt;/span&gt; &lt;/child&gt;&lt;/template&gt; 给slot传入普通文本 给slot传入了一个图像处理组件 具名插槽也很简单，比如有多个插槽，我作为父组件，肯定想区别子组件中的几个插槽，那就要用slot标签的name属性来标识了，而父组件要决定在什么插槽里面放什么内容，就要将name的值赋值给slot属性传递给对应的插槽。如果slot没有name属性，就是匿名插槽了，而父组件中不指定slot属性的内容，就会被丢到匿名插槽中。 12345678910111213141516171819// 子组件&lt;template&gt; &lt;section&gt; &lt;slot name=&quot;article-title&quot;&gt;这里放标题&lt;/slot&gt; &lt;slot&gt;这里放作者&lt;/slot&gt; &lt;slot name=&quot;article-content&quot;&gt;这里放文章内容&lt;/slot&gt; &lt;/section&gt;&lt;/template&gt;// 父组件&lt;template&gt; &lt;section&gt; &lt;slot-child&gt; &lt;h1 slot=&quot;article-title&quot;&gt;vue作用域插槽，你真的懂了吗？&lt;/h1&gt; &lt;p slot=&quot;article-content&quot;&gt;好像有点懂了&lt;/p&gt; &lt;div&gt;王五&lt;/div&gt; &lt;/slot-child&gt; &lt;/section&gt;&lt;/template&gt; 最难理解的是作用域插槽。看了文档说明的朋友可能还会有点晕，大概是说在作用域插槽内，父组件可以拿到子组件的数据。子组件可以在slot标签上绑定属性值，如： 1&lt;slot :nickName=&quot;&apos;Tusi&apos;&quot;&gt;&lt;/slot&gt; 而父组件通过slot-scope绑定的对象下拿到nickName的值。 123456789&lt;template&gt; &lt;section&gt; &lt;slot-child&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;div&gt;{{scope.nickName}}&lt;/div&gt; &lt;/template&gt; &lt;/slot-child&gt; &lt;/section&gt;&lt;/template&gt; 这里大家应该都有疑问。这有什么用？我在子组件用$emit向父组件传递数据不就行了？ 关于作用域插槽的一点理解我觉得要从组件之间的数据流向来思考作用域插槽的应用场景。 假设第一个场景，需要你写一个商品卡片组件，并通过循环去展示多个卡片，并且要求能响应每个卡片上的图片或者其他内容的点击事件而跳转到商品详情页，你会怎么写？ 我会使用如下的处理方式，首先将商品卡片写成一个组件Commodity.vue，而在CommodityList.vue中用一个v-for来处理商品卡片列表的展示。 1&lt;commodity v-for=&quot;(item,index) in commodities&quot; @clickCommodity=&quot;onCommodityClick&quot;&gt;&lt;/commodity&gt; Commodity组件通过$emit像父组件传递clickCommodity事件，并携带商品数据，父组件即可在onCommodityClick方法中得到数据，进行业务处理，这样便完成了一个基本的由子到父的数据传递。 如果再往上抽象一下呢？比如我有多个运营栏目，像淘宝首页有“有好货”，“爱逛街”这样两个栏目，每个栏目下都需要有一个商品卡片列表，那么商品卡片列表CommodityList.vue就要抽成组件了。而这个包含多个运营栏目的vue组件我假设它叫ColumnList.vue，在其中通过v-for调用了CommodityList组件。 注意：业务来了，我希望把点击商品卡片的业务放在ColumnList.vue中处理。你们想象一下要怎么做？一种土办法就是商品按钮点击时，Commodity组件$emit通知CommodityList.vue，而CommodityList接着把事件用$emit往上抛，那么ColumnList.vue就能处理这个点击事件了。这样做完全没有问题，但是显得子组件很不纯粹，跟业务都扯上关系了。 那么如何优雅地解决这个问题呢？这个时候，作用域插槽真正派上用场了。 通过作用域插槽将本应该由CommodityList处理的商品卡片点击业务onCommodityClick提升到ColumnList处理。 12345678910111213141516&lt;el-row :gutter=&quot;20&quot;&gt; &lt;el-col :span=&quot;12&quot; v-for=&quot;(column, index) in columnList&quot; :key=&quot;index&quot;&gt; &lt;el-card class=&quot;box-card card-column&quot;&gt; &lt;div slot=&quot;header&quot; class=&quot;clearfix&quot;&gt; &lt;span&gt;{{column.columnName}}&lt;/span&gt; &lt;/div&gt; &lt;commodity-list :commodities=&quot;column.commodityList&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!-- 这里只需要给Commodity组件传入数据，响应Commodity组件的clickCommodity事件即可。 事件不必携带参数，完全符合父到子的数据流向，而不会发生子组件又给父组件反向发数据的情况 --&gt; &lt;commodity :modityData=&quot;scope.row&quot; @clickCommodity=&quot;onCommodityClick(scope.row)&quot;&gt;&lt;/commodity&gt; &lt;/template&gt; &lt;/commodity-list&gt; &lt;/el-card&gt; &lt;/el-col&gt;&lt;/el-row&gt; 而CommodityList组件内部应该是改造成这样，slot接收来自父组件的商品卡片组件，这里面不涉及关于商品组件的业务，只关注其他业务和布局即可。最终就实现了组件和业务的剥离，这也是组件化的精髓所在吧。不知道有没有帮到您呢？ 12345&lt;el-row :gutter=&quot;20&quot;&gt; &lt;el-col :span=&quot;8&quot; v-for=&quot;(item, index) in commodities&quot; :key=&quot;index&quot; style=&quot;margin-top:20px;&quot;&gt; &lt;slot :row=&quot;item&quot;&gt;&lt;/slot&gt; &lt;/el-col&gt;&lt;/el-row&gt; 这是我实现的效果，忽略样式吧，原理都懂了，做个漂亮的卡片有多难？ 总结一下，作用域插槽适合的场景是至少包含三级以上的组件层级，是一种优秀的组件化方案！","link":"/vue作用域插槽，你真的懂了吗.html"},{"title":"vue全家桶版本升级排错","text":"背景如果你使用了element-ui的el-tabs组件，并且想要单独升级element-ui至2.10.0，你会发现，使用了el-tabs组件的页面只要打开就卡死。原因是element-ui~2.10.0采用了不兼容vue~2.5.10的写法。于是我尝试系统性升级vue全家桶，这也是为系统赋予更多能力做准备。结果遇到一些报错，这里记录一下。 升级过程当前版本vue: 2.5.10 vue-loader: 13.5.0 vue-router: 3.0.1 vuex: 3.0.1 axios: 0.17.1 element-ui: 2.2.2 目标版本vue: 2.6.10 vue-loader: 15.7.0 vue-router: 3.0.3 vuex: 3.1.1 axios: 0.18.1 element-ui: 2.10.0 报错1(包版本不匹配)修改package.json中的依赖包版本号之后，npm install一波后就报错了。 123456789101112131415Vue packages version mismatch:- vue@2.6.10- vue-template-compiler@2.5.10This may cause things to work incorrectly. Make sure to use the same version for both.If you are using vue-loader@&gt;=10.0, simply update vue-template-compiler.If you are using vue-loader@&lt;10.0 or vueify, re-installing vue-loader/vueify should bump vue-template-compiler to the latest. @ ./src/router/modules/test/index.js 22:23-67 @ ./src/router/common.js @ ./src/router/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js 分析：vue和vue-template-compiler两个包的版本不匹配，需要升级vue-template-compile。github搜索这个包搜不到，最后在npm包官网找到了。 解决方案：升级vue-template-compile: 2.6.10 报错2(vue-loader)1234567891011121314151617|| &lt;section&gt;| &lt;el-form class=\"cl-add-form\" :model=\"dataForm\" :rules=\"rules\" ref=\"dataForm\" label-width=\"125px\"&gt;| &lt;el-form-item label=\"法定节假日名称\" prop=\"name\"&gt; @ ./src/views/backend/enterprise/holiday/add-public-holiday.vue 1:0-97 30:4-35:6 30:81-35:5 @ ./src/views lazy ^\\.\\/.*$ @ ./src/authority/generate-routes.js @ ./src/store/modules/user.js @ ./src/store/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js error in ./src/views/backend/enterprise/holiday/add-special-holiday.vue?vue&amp;type=template&amp;id=09f84cb0&amp;Module parse failed: Unexpected token (2:0)You may need an appropriate loader to handle this file type. 分析：经观察，发现可能是不识别vue文件或其中某部分，于是从vue-loader入手，也在网上查阅了一些资料，需要在webpack的plugins中加入vue-loader/lib/plugin。 解决方案： 1234567const VueLoaderPlugin = require('vue-loader/lib/plugin')plugins: [ new VueLoaderPlugin(), // 其他插件 ...] 报错3(postcss-loader)12345678910111213141516171819(Emitted value instead of an instance of Error) ⚠️ PostCSS LoaderPrevious source map found, but options.sourceMap isn't set.In this case the loader will discard the source map entirely for performance reasons.See https://github.com/postcss/postcss-loader#sourcemap for more information. @ ./node_modules/vue-style-loader!./node_modules/css-loader?{\"sourceMap\":false}!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/lib?{\"sourceMap\":false}!./node_modules/vue-loader/lib?{\"loaders\":{\"css\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}}],\"postcss\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}}],\"less\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"less-loader\",\"options\":{\"sourceMap\":false}}],\"sass\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"sass-loader\",\"options\":{\"indentedSyntax\":true,\"sourceMap\":false}}],\"scss\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"sass-loader\",\"options\":{\"sourceMap\":false}}],\"stylus\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"stylus-loader\",\"options\":{\"sourceMap\":false}}],\"styl\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"stylus-loader\",\"options\":{\"sourceMap\":false}}]},\"cssSourceMap\":false,\"cacheBusting\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./src/views/iot-supervise/truck/truck-carousel.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp; 4:14-1577 14:3-18:5 15:22-1585 @ ./src/views/iot-supervise/truck/truck-carousel.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp; @ ./src/views/iot-supervise/truck/truck-carousel.vue @ ./src/views lazy ^\\.\\/.*$ @ ./src/authority/generate-routes.js @ ./src/store/modules/user.js @ ./src/store/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js 分析：这里面的错误是关于postcss-loader的，只要将config/index.js中dev.cssSourceMap设置为true即可。 警告1(svg-sprite-loader)升级过程中还遇到了一个警告，虽然不影响功能，但是看着还是很难受的。 12345678in ./src/icons/svg/workList.svgsvg-sprite-loader exception. 28 rules applies to D:\\coollu\\projects\\coollu-v3\\source-code\\v1.0.1\\update-elementui-test\\src\\icons\\svg\\workList.svg @ ./src/icons/svg \\.svg$ @ ./src/icons/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js 搜索关键词后，发现网上并没有此类答案。因此我考虑是版本问题，于是升级svg-sprite-loader至最新版本4.1.6，解决了这个警告问题。 总结至此升级过程就完成了！顺便一提，系统性升级必须要经过全面测试，否则你难以保证完全向下兼容哦！","link":"/vue全家桶版本升级排错.html"},{"title":"vue学习过程的个人笔记","text":"我学习和使用angular也有两年了。期间也接触过react，vue，简单地学习过。现在也想好好学一下vue，于是我在这里记录一下学习的大概过程。 安装vue-cli之前用嵌入script标签的方式撸过一遍vue的一些特性，包括vue-router。这里我使用vue-cli的方式来安装一下。 1npm install --global vue-cli 生成vue项目1vue init webpack vuecms 命令中的webpack是指生成一个基于webpack的项目。vue-cli生成项目过程的最后一个会提示你选择是否自动执行npm install，我选择了yes，或者cd到项目目录下运行npm install安装依赖也可以。安装依赖的时间有点长，请耐心等待！ 启动vue项目1npm start 该命令会执行npm run dev，默认端口是8080，我个人喜欢改端口，在dev脚本后加上–port=3200即可。 打包vue项目1npm run build 运行该命令后，会执行build.js。webpack的配置文件主要涉及build和config两个目录，后面修改这两个目录中的文件应该可以进行定制。 我们build项目之后，直接把index.html拖到浏览器中是不可以访问的。要么放在服务器上进行访问，要么就是使用http-server进行测试。 1npm install -g http-server 安装http-server后，我们cd到dist目录下，启动http-sever 12// 键入这个命令即可启动http-server服务http-server 然后我们就可以通过http://127.0.0.1:8080/index.html访问打包后的项目了。","link":"/vue学习过程的个人笔记.html"},{"title":"vue开发过程问题汇总记录","text":"这篇文章记录一下vue开发过程中遇到的一些问题及解决方案。 vue中static文件夹与assets文件夹区别简单的讲，static放别人家的，assets放自己写的。不知道这个解释是否OK，这里有一篇资料参考。 favicon显示不出来1&lt;link rel=\"icon\" href=\"assets/logo.png\" type=\"image/x-icon\"/&gt; index.html添加favicon后，显示不出来。调整href的路径，也是显示不不了。在网上找到两个方法：（1）使用static目录将favicon图片放在static目录下 12// 经测试，开发环境和生产环境都OK&lt;link rel=\"icon\" href=\"static/logo.png\" type=\"image/x-icon\"/&gt; （2）配置webpack不用在index.html中添加link标签，修改webpack的HtmlWebpackPlugin，添加配置项： 1favicon: 'logo.png' 我这里为了简单，直接复制的logo.png到src同级目录下。正式的应该是一个favicon.ico图标。 vue-devtools安装和使用（1）clone vue-devtools克隆的https链接为https://github.com/vuejs/vue-devtools（2）npm install在工具目录下安装依赖。（3）npm run build打包构建工具。（4）chrome添加扩展程序将shells&gt;chrome目录直接拖到扩展程序中。（5）在工具目录下运行npm run dev（6）在chrome调试vue项目时，打开开发者工具，有一项Vue的插件，即可用来调试Vue，非常方便。 vue中怎么使用scss语法首先，安装node-sass和sass-loader。 12npm install node-sass --save-devnpm install sass-loader --save-dev 然后，在vue文件中给style标签加上lang属性。 1&lt;style lang=\"scss\"&gt; vue-loader支持css预处理器，因此不需要额外写sass的loader了，所以我前面安装的sass-loader可能是多余的。 使用element-ui（1）安装：npm i element-ui -S（2）在 main.js 中引入： Updating……","link":"/vue开发过程问题汇总记录.html"},{"title":"web网页加载圈之入门篇","text":"作为一名web开发者，或多或少都会接触到网页加载圈这个概念。一个网站的加载速度或快或慢，而慢的网页加载速度会给用户非常差的体验，这个时候如果不给用户一点提示信息，那简直糟糕透了。因此，常见的做法，是在页面加载完成之前，给一个过渡效果。那么怎么实现这种效果呢？ 如何知道网页加载完成DOM给我们提供了这样一个方法document.onreadystatechange。当一个文档的readyState属性发生更改时，readystatechange事件会被触发。document.readyState有两个值，interactive和complete。interactive状态表示文档已经完成加载，文档已被解析，但是诸如图像，样式表和框架之类的子资源仍在加载。complete状态则表示页面加载结束。那么我们可以在页面上写一个提示信息，当document.readyState变为complete状态就隐藏这个提示，这样就可以达到一个过渡的效果了。 文字提示效果我们从最简单的开始，可以给用户一个文字提示，比如“Loading…”。那么代码怎么写呢？ 绘制加载提示第一步，在body中绘制加载提示。 1&lt;div id=\"loading\"&gt;Loading...&lt;/div&gt; 第二步，给提示内容一个居中的样式效果。在style标签中写样式 1234567#loading { position: absolute; width: 50px; height: 50px; left: 50%; top: 50%;} 打开该html页面，我们可以看到初步的效果。 根据状态隐藏提示利用document.onreadystatechange方法监听页面加载状态，当document.readyState变为complete状态就隐藏加载提示。加入script标签，写入以下代码。 123456document.onreadystatechange = () =&gt; { if (document.readyState === 'complete') { var loadingElement = document.getElementById('loading'); loadingElement.parentNode.removeChild(loadingElement); }}; 刷新html页面，我们可以看到，当页面加载完成时，提示内容自动消失了。（由于资源缓存的关系，第二次的效果不会太明显，可以清空缓存观察效果。） 图片加载效果网上有很多加载圈的gif图片，将上述文字内容换成gif图片就可以做到。也可以使用静态图片，然后通过css3动画来做一些加载效果，如rotate旋转。 1234567891011121314#loading { position: absolute; width: 50px; height: 50px; left: 50%; top: 50%; background: url(loading.jpg) center center no-repeat; background-size: 100% 100%; animation: rotate 1.5s ease-out infinite;}@keyframes rotate { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);}} css3自定义加载效果其实我们可以利用CSS3自定义加载效果，把我们想要的效果通过动画做出来即可。下面我们来实现一个圆弧加载效果。只要将背景图换成box-shadow效果即可。 123border-radius: 50%;box-shadow: 2px 0 black;animation: rotate 1.5s ease-out infinite; 这是我做的加载圈的效果页面，请点击查看。","link":"/web网页加载圈之入门篇.html"},{"title":"windows系统下安装mysql8.0","text":"下载mysql进入到官网下载页面，下载免费的社区版就可以了。本人一开始下载了installer，安装卸载了两次，可能是使用不当吧，遇到了很多坑，最终选择了下载zip版本。 ) 如何安装使用将下载的zip压缩包解压到D:\\Program Files\\MySQL目录下，创建my.ini配置文件 123456789101112131415161718192021222324[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\Program Files\\MySQL# 设置mysql数据库的数据的存放目录datadir=D:\\Program Files\\MySQL\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 然后在bin目录下依次运行以下命令 12mysqld --installmysqld --initialize 会得到一个初始的密码，如kh5sN)zd=fsw。 还要配置一下环境变量，在PATH后追加以下内容 1;D:\\Program Files\\MySQL\\bin 接着运行net start mysql，可以看到启动mysql服务已经成功。 测试root账号运行登录命令 1mysql -u root -p 输入密码后登录成功。 接着输入数据库查询语句，随便输什么都报一个错。比如show databases，use mysql等。 You must reset your password using ALTER USER statement before executing this statement. 上网查了一下后，说是密码过期了，需要修改，我就纳闷了，刚初始化得到的密码就过期了。。。 不说了，运行这个命令，修改一下root的密码。 1alter user user() identified by &quot;123456&quot;; 修改后，就可以正常访问使用mysql数据库了。 2018.8.7 今天在win10上按照以上步骤安装时，遇到了一个问题。运行net start mysql时报错 123发生系统错误 2。系统找不到指定的文件。 解决方案：打开注册表，找到 HKEY_LOCAL_MACHINE -&gt; SYSTEM -&gt; CurrentControlSet -? services -&gt; mysql -&gt; ImagePath 发现这个值是C盘下的某路径，跟我放在D盘的MySQL目录不符。 需要修改成 1&quot;D:\\Program Files\\MySQL\\bin\\mysqld&quot; MySQL","link":"/windows系统下安装mysql8-0.html"},{"title":"web网页加载圈之进阶篇","text":"做完简单的加载效果后，相信大家也想接着做一些更为复杂的效果。我也是这么想的。很多网页的加载动画都是由很多帧组成的，要做到这种效果也不难，说到底就是看你拆分动画的思路。下面讲一个简单的例子。 从左到右循序渐进的加载效果一个典型的动画加载效果就是，从左到右循序渐进的圆点加载。效果如下：那么怎么来实现这种效果呢？ 绘制n个圆点我这里绘制了6个圆点，相信画圆点应该难不倒各位。 12border-radius: 50%;background-color: gray; 如何做圆点的动画效果我这里采用的方案是背景色变化，每个圆点的颜色按照顺序依次由灰色变为红色。那么具体怎么做呢？ 定义关键帧这里先定义关键动画帧，描述背景色的变化过程。 1234@keyframes highlightBack { 0% { background-color: gray; } 100% { background-color: red; }} 应用动画使用animation属性来应用highlightBack，并给到0.2s的一个动画时间。 123.loading-animate { animation: highlightBack 0.2s ease forwards;} 设计动画过渡效果我需要圆点的颜色一个个变化，那么执行动画的时间点就必须不一样。因此我给了每一个圆点不一样的animation-delay值。 1234// 比如第二个圆点，我给它的动画时延是0.2s，相当于第一个圆点的动画执行完了，才执行第二个圆点的动画。.loading-point:nth-child(2) { animation-delay: 0.2s;} 一轮动画结束后怎么重新开始页面加载的时间或长或短，不可能动画只执行一轮就结束了。所以我们需要让一轮动画结束后，接着开始第二轮的动画。具体怎么做呢？我们可以监听最后一个圆点的动画结束事件animationend，然后在回调函数中移除动画类，经过短暂的延时后，重新添加动画类即可做到。 123456789101112// 关键代码document.getElementById('last').addEventListener('animationend', () =&gt; { var points = document.getElementsByClassName('loading-point'); for (var i = 0; i &lt; points.length; i++) { points[i].classList.remove('loading-animate'); } setTimeout(() =&gt; { for (var i = 0; i &lt; points.length; i++) { points[i].classList.add('loading-animate'); } }, 500);}); 根据状态隐藏圆点这个跟上文说的是一样的，当document.readyState的值为complete时，隐藏圆点。点击参考上文。到此就完成了整个效果，点击查看效果页面。","link":"/web网页加载圈之进阶篇.html"},{"title":"一种在地图中处理曲线的通用方法","text":"本文分享一种可以用于处理曲线的算法，是本人在百度地图开源库基础上改造的，可以用于其他地图场景中处理点数据，只要两个以上的点，就可以得到平滑的曲线。例如小程序，将处理后得到的点赋值给polyline的points即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192function getCurveByTwoPoints(obj1, obj2) { if (!obj1 || !obj2) { return null } var B1 = function (x) { return 1 - 2 * x + x * x }; var B2 = function (x) { return 2 * x - 2 * x * x }; var B3 = function (x) { return x * x }; curveCoordinates = []; var count = 30; var isFuture = false; var t, h, h2, lat3, lng3, j, t2; var LnArray = []; var i = 0; var inc = 0; if (typeof(obj2) == \"undefined\") { if (typeof(curveCoordinates) != \"undefined\") { curveCoordinates = [] } return } var lat1 = parseFloat(obj1.lat); var lat2 = parseFloat(obj2.lat); var lng1 = parseFloat(obj1.lng); var lng2 = parseFloat(obj2.lng); if (lng2 &gt; lng1) { if (parseFloat(lng2 - lng1) &gt; 180) { if (lng1 &lt; 0) { lng1 = parseFloat(180 + 180 + lng1) } } } if (lng1 &gt; lng2) { if (parseFloat(lng1 - lng2) &gt; 180) { if (lng2 &lt; 0) { lng2 = parseFloat(180 + 180 + lng2) } } } j = 0; t2 = 0; if (lat2 == lat1) { t = 0; h = lng1 - lng2 } else { if (lng2 == lng1) { t = Math.PI / 2; h = lat1 - lat2 } else { t = Math.atan((lat2 - lat1) / (lng2 - lng1)); h = (lat2 - lat1) / Math.sin(t) } } if (t2 == 0) { t2 = (t + (Math.PI / 5)) } h2 = h / 2; lng3 = h2 * Math.cos(t2) + lng1; lat3 = h2 * Math.sin(t2) + lat1; for (i = 0; i &lt; count + 1; i++) { curveCoordinates.push( { lng: (lng1 * B1(inc) + lng3 * B2(inc)) + lng2 * B3(inc), lat: (lat1 * B1(inc) + lat3 * B2(inc) + lat2 * B3(inc)) } ); inc = inc + (1 / count) } return curveCoordinates}function getCurvePoints(points) { var curvePoints = []; for (var i = 0; i &lt; points.length - 1; i++) { var p = getCurveByTwoPoints(points[i], points[i + 1]); if (p &amp;&amp; p.length &gt; 0) { curvePoints = curvePoints.concat(p) } } return curvePoints}let trackPoints = [{lng:113.281, lat:29.203}, {lng:113.567, lat:29.301}]let convertPoints = getCurvePoints(trackPoints)console.log(convertPoints) 最后再给一个微信小程序应用实例 map.wxml 12// 举个小程序应用的例子&lt;map id=\"map\" longitude=\"113.324520\" latitude=\"23.099994\" scale=\"14\" controls=\"{{controls}}\" bindcontroltap=\"controltap\" markers=\"{{markers}}\" bindmarkertap=\"markertap\" polyline=\"{{polyline}}\" bindregionchange=\"regionchange\" show-location style=\"width:100vw;height:100vh;\"&gt;&lt;/map&gt; map.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127Page({ data: { markers: [{ iconPath: \"/resources/marker.png\", id: 0, latitude: 23.099994, longitude: 113.324520, width: 50, height: 50 }], polyline: [], controls: [{ id: 1, iconPath: '/resources/location.png', position: { left: 0, top: 300 - 50, width: 50, height: 50 }, clickable: true }] }, onLoad() { this.setData({ polyline:[{ points: this.getCurvePoints([{ lng: 113.3245211, lat: 23.10229 }, { lng: 113.324520, lat: 23.21229 }]), color: \"#FF0000DD\", width: 2 }] }) }, regionchange(e) { console.log(e.type) }, markertap(e) { console.log(e.markerId) }, controltap(e) { console.log(e.controlId) }, getCurveByTwoPoints(obj1, obj2) { if (!obj1 || !obj2) { return null } var B1 = function (x) { return 1 - 2 * x + x * x }; var B2 = function (x) { return 2 * x - 2 * x * x }; var B3 = function (x) { return x * x }; var curveCoordinates = []; var count = 30; var isFuture = false; var t, h, h2, lat3, lng3, j, t2; var LnArray = []; var i = 0; var inc = 0; if (typeof (obj2) == \"undefined\") { if (typeof (curveCoordinates) != \"undefined\") { curveCoordinates = [] } return } var lat1 = parseFloat(obj1.lat); var lat2 = parseFloat(obj2.lat); var lng1 = parseFloat(obj1.lng); var lng2 = parseFloat(obj2.lng); if (lng2 &gt; lng1) { if (parseFloat(lng2 - lng1) &gt; 180) { if (lng1 &lt; 0) { lng1 = parseFloat(180 + 180 + lng1) } } } if (lng1 &gt; lng2) { if (parseFloat(lng1 - lng2) &gt; 180) { if (lng2 &lt; 0) { lng2 = parseFloat(180 + 180 + lng2) } } } j = 0; t2 = 0; if (lat2 == lat1) { t = 0; h = lng1 - lng2 } else { if (lng2 == lng1) { t = Math.PI / 2; h = lat1 - lat2 } else { t = Math.atan((lat2 - lat1) / (lng2 - lng1)); h = (lat2 - lat1) / Math.sin(t) } } if (t2 == 0) { t2 = (t + (Math.PI / 5)) } h2 = h / 2; lng3 = h2 * Math.cos(t2) + lng1; lat3 = h2 * Math.sin(t2) + lat1; for (i = 0; i &lt; count + 1; i++) { curveCoordinates.push( { longitude: (lng1 * B1(inc) + lng3 * B2(inc)) + lng2 * B3(inc), latitude: (lat1 * B1(inc) + lat3 * B2(inc) + lat2 * B3(inc)) } ); inc = inc + (1 / count) } return curveCoordinates }, getCurvePoints(points) { var curvePoints = []; for (var i = 0; i &lt; points.length - 1; i++) { var p = this.getCurveByTwoPoints(points[i], points[i + 1]); if (p &amp;&amp; p.length &gt; 0) { curvePoints = curvePoints.concat(p) } } return curvePoints }}) 献上效果图：","link":"/一种在地图中处理曲线的通用方法.html"},{"title":"二级域名解析配置方法","text":"昨天将基于express的后台服务器部署在了腾讯云主机上，使用IP可以正常访问到我的angular demo了。这里给大家提供一个测试账号（账号：test，密码：0）。接着我就想，是不是可以换成域名访问呢？答案当然是可以的。于是我准备把云主机解析到我的二级域名下。 解析二级域名很多网站都会有二级域名，形如blog.xxx.com，bbs.xxx.com等等，玩过域名解析的同学应该大概有个概念了。那么如何配置二级域名解析呢？ 打开阿里云控制台，来到域名管理处 点击“添加解析” 我们要将二级域名解析到云主机上，那么就是解析到ip，所以选择A记录 主机记录就是我们要定义的二级域名名称，自己合理随意即可 记录值则是云主机IP 点击确认则添加完成，二级域名解析的工作也宣告完成！这里就可以用二级域名访问试下了。","link":"/二级域名解析配置方法.html"},{"title":"从部署上做到前后端分离","text":"前言记得在让Nodejs支持H5 History模式（connect-history-api-fallback源码分析）一文中提到了HTML5的History Mode。然而在最近的使用过程中发现connect-history-api-fallback这个包效果并不是那么理想，用一段时间就会报错。而且本身我的博客项目前后端并未完全分离，虽然开发时是独立的工程，但是前端工程打包后还是放在了express的静态资源文件夹下进行部署。考虑到这两个痛点，我决定在nginx配置中对前后端进行部署分离。 前端独立部署前端工程npm run build打包后，不再copy到后端工程public目录下。而是独立部署在nginx的静态资源目录下，我放置的目录是/usr/nginx/share/html/blog 相关nginx配置如下： 12345678910111213#博客转发 blog.wbjiang.cnserver { listen 80; server_name blog.wbjiang.cn; root /usr/share/nginx/html/blog; access_log logs/blog.log; error_log logs/blog.error; #博客静态文件 location / { try_files $uri /index.html; }} 小建议：可以在开发新功能完毕后，就将打包完毕的代码提交到仓库的release分支，然后直接在linux服务器上对应目录下的Git仓库中git pull，也算是半自动化部署了（后面也准备研究下全自动化部署）。 后端接口转发blog.wbjiang.cn/api前缀的视为接口请求，统一转发到express后台服务。配置如下： 12345678910#api转发location /api { proxy_pass http://blog_pool; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; rewrite ^/api/(.*)$ /$1 break;} 负载均衡池配置（虽然只有一个服务，手动“狗头”） 123upstream blog_pool{ server 127.0.0.1:8002;} 重启服务pm2重启 1pm2 restart blog nginx重启 1nginx -s reload","link":"/从部署上做到前后端分离.html"},{"title":"一张图带你了解webpack的require.context","text":"很多人应该像我一样，对于webpack的require.context都是一知半解吧。网上很多关于require.context的使用案例，但是我没找到可以帮助我理解这个知识点的，于是也决定自己来探索一下。下面以网上流行的svg图标方案为例说明。对了，本文的重点是require.context，并不会去解释svg symbol方案svg-sprite-loader。 关键代码 src/icons/index.js 123const context = require.context(\"./svg\", true, /\\.svg$/)context.keys().map(context) main.js 1import '@/icons' webpack.base.config.js 1234567891011121314151617{ test: /\\.svg$/, loader: \"svg-sprite-loader\", include: [resolve(\"src/icons\")], options: { symbolId: \"icon-[name]\" }},{ test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: \"url-loader\", exclude: [resolve(\"src/icons\")], options: { limit: 10000, name: utils.assetsPath(\"img/[name].[hash:7].[ext]\") }}, why? 很多人跟我一样，一开始只想说，为什么这样就可以，why??? 要知道是什么，就上打印大法。 12345const context = require.context(\"./svg\", true, /\\.svg$/)// 看看你是何方神圣console.log(context)context.keys().map(context) 下面就真的以一张图进行解释，有问题的欢迎留言交流呀！","link":"/一张图带你了解webpack的require-context.html"},{"title":"前端利器SASS之入门篇","text":"前端开发过程中，我们会给各个元素指定样式，甚至有很多重复的样式，在后期维护过程中，如果我们要改动一些页面样式，可能得一个个css文件去修改，这样非常麻烦。好在有SASS这样一个神器来帮我们完成CSS的拓展和管理。那么什么是SASS? Sass（Syntactically Awesome StyleSheets，非常棒的语法结构化层叠样式表，我瞎翻译的） 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。 想要真正掌握SASS语法，就得一条一条学啊。 SASS对CSS的拓展支持嵌套12345#main { #home { background: red; }} 支持父选择器&amp;1234a { font-weight: normal; &amp;:hover { font-weight: bold; }} 支持属性嵌套12345678910111213.home { font: { family: fantasy; size: 30px; weight: normal; }}// 上述代码相当于css的如下代码.home { font-family: fantasy; font-size: 30px; font-weight: normal; } SassScriptSass支持一些类似js的语法，为我们提供了很多强大的功能。 变量（1）声明变量 1$nav-bgc: rgba(0, 0, 0, .2); （2）引用变量 1background: $nav-bgc; （3）!default可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。 12345678$content: \"First content\";$content: \"Second content?\" !default;$new_content: \"First time reference\" !default;#main { content: $content; // \"First content\" new-content: $new_content; // \"First time reference\"} ps：变量是 null 空值时将视为未被 !default 赋值。如果第一个$content的值是null，那么将会取$content: “Second content?” !default的值。 数据类型SASS支持的数据类型主要有以下几种： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) 支持运算符 运算规则与js类似，但有一些特别的地方，具体请参考SASS教程。 插值语法#{}通过 #{} 插值语句可以在选择器或属性名或属性值中使用变量。使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。比如下面用到的font写法。 12345678$name: foo;$attr: border;$font-size: 12px;$line-height: 30px;p.#{$name} { #{$attr}-color: blue; font: #{$font-size}/#{$line-height};} @extend@extend可以实现继承，适用于一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。在不使用@extend时，我们完全可以定义两个class来实现，如： 1234567891011// css部分.error { border: 1px #f00; background-color: #fdd;}.seriousError { border-width: 3px;}// html部分&lt;div class=&quot;error seriousError&quot;&gt;&lt;/div&gt; 但是使用@extend能为我们带来更多的好处，简洁易维护。 12345.seriousError { border-width: 3px; @extend .error;}&lt;div class=\"seriousError\"&gt;&lt;/div&gt; 控制指令（1）@if当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码 123p { @if true { border: 1px solid; }} @if后面可以接@else if和@else语句（2）@for这个指令包含两种格式： 12@for $var from &lt;start&gt; through &lt;end&gt;@for $var from &lt;start&gt; to &lt;end&gt; 区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 &lt;start&gt; 与 &lt;end&gt;的值，而使用 to 时条件范围只包含 &lt;start&gt; 的值不包含 &lt;end&gt; 的值。（3）@each 12345678910111213141516171819// @each 遍历值数组中的每一项，然后输出结果$var in &lt;list&gt; {}// @each 可遍历多维数组，如下所示// $animal接收来自(puma, black, default)的数据，$color接收来自(red, blue, green)的数据，依次类推。@each $animal, $color, $cursor in (puma, black, default), (red, blue, green), (pointer, default, move) { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); border: 2px solid $color; cursor: $cursor; }}// @each 除了可以遍历数组，还可以遍历maps，如下所示@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) { #{$header} { font-size: $size; }} （3）@while与js的while循环类似 12345$i: 6;@while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2;} @mixin混合器@mixin是sass中一个非常重要的概念，用于定义可重复使用的样式。 @mixin的定义12345678@mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000;} @mixin的使用123456// 使用 @include 指令引用混合样式.page-title { @include large-text; padding: 4px; margin-top: 10px;} ps：@mixin中也可以@include其他混合器。 带参数的混合器12345678910111213141516171819@mixin sexy-border($color, $width) { border: { color: $color; width: $width; style: dashed; }}p { @include sexy-border(blue, 1in); }// 可以设置默认参数，如：@mixin sexy-border($color, $width: 2px) {// 有时候我们不知道会传入几个参数，比如不知道要设置几个box-shadow，所以可以这样使用。@mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;}.shadows { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);} 允许向@mixin中插入内容在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方： 1234567891011121314@mixin apply-to-ie6-only { * html { @content; }}@include apply-to-ie6-only { #logo { background-image: url(/logo.gif); }}// 上述代码会编译成：* html #logo { background-image: url(/logo.gif);} 函数@functionSASS拥有一些内置函数，也支持自定义函数。 12345678$parent-width: 40px;$self-width: 10px;@function get-left($n) { @return (parent-width - self-width) / 2;}#somediv { left: get-left(5); } ps：函数的语法类似于mixin，但是函数返回的是一个值，而不是一段css。","link":"/前端利器SASS之入门篇.html"},{"title":"利用gulp优化web页面加载速度","text":"利用hexo搭建好博客之后，发现博客页面加载速度特别慢，这一点在手机端比较明显。关闭了粒子动画效果后，页面加载的速度没有得到明显改善，于是想从其他方面来提升加载速度。而压缩代码则是一个最直接的方式。 压缩htmlgulp-htmlmin是一个用于压缩html文件的插件，安装方法如下： 1npm install --save-dev gulp-htmlmin 使用方法如下： 12345678910111213141516var gulp = require(&apos;gulp&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;); gulp.task(&apos;minifyHtml&apos;, function() { var minifyOptions = { collapseWhitespace: true, // 折叠html节点间的空白 minifyCSS: true, // 压缩css minifyJS: true, // 压缩js removeComments: true, // 去除注释 removeEmptyAttributes: true, // 去除空属性 removeRedundantAttributes: true // 去除与默认属性一致的属性值 }; return gulp.src(&apos;src/*.html&apos;) .pipe(htmlmin(minifyOptions)) .pipe(gulp.dest(&apos;dist&apos;));}); 这个插件还有很多的配置项，请参考Options Quick Reference。 ps：html文件中可以嵌入js以及css内容，因此该插件支持对html文件中js及css内容的压缩。 压缩css我之前用过一个gulp-minify-css插件来压缩css文件，不过最近发现它已经被废弃了，取而代之的是gulp-clean-css，安装方法如下： 1npm install gulp-clean-css --save-dev 使用方法如下： 12345678var gulp = require(&apos;gulp&apos;);var cleanCSS = require(&apos;gulp-clean-css&apos;); gulp.task(&apos;minifyCss&apos;, () =&gt; { return gulp.src(&apos;styles/*.css&apos;) .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) .pipe(gulp.dest(&apos;dist&apos;));}); gulp-clean-css的配置项挺多的，感觉还是要遇到具体问题，具体分析了。配置项参考clean-CSS。 压缩js我们可以用gulp-uglify插件来进行js文件的压缩。首先，我们来安装它： 1npm install --save-dev gulp-uglify 使用方法如下： 1234567891011var gulp = require(&apos;gulp&apos;);var uglify = require(&apos;gulp-uglify&apos;);var pump = require(&apos;pump&apos;); gulp.task(&apos;compress&apos;, function (cb) { pump([ gulp.src(&apos;lib/*.js&apos;), uglify(), gulp.dest(&apos;dist&apos;) ], cb);}); 这里用到了一个pump插件，其实不需要它也是完全可以正常压缩js文件的。但是pump插件为我们提供了一个排错的能力，能够打印出压缩js文件过程的具体错误信息，让我们快速定位修改。ps：gulp-uglify支持一些配置项，请参考Minify options。 压缩图片资源压缩图片资源也是优化web页面的一个重要方法，而gulp-imagemin插件可以帮我们做到这一点。首先，我们来安装它： 1npm install --save-dev gulp-imagemin 经典的用法如下： 12345678var gulp = require(&apos;gulp&apos;);var imagemin = require(&apos;gulp-imagemin&apos;); gulp.task(&apos;default&apos;, () =&gt; gulp.src(&apos;src/images/*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/images&apos;))); imagemin()也可以传入配置参数，主要的一些配置项如下所示： 12345678910111213….pipe(imagemin([ imagemin.gifsicle({interlaced: true}), //优化gif imagemin.jpegtran({progressive: true}), //优化jpg,jpeg imagemin.optipng({optimizationLevel: 5}), //优化png imagemin.svgo({ plugins: [ {removeViewBox: true}, {cleanupIDs: false} ] }) //优化svg]))… 这里有两个单词需要注意一下，interlaced和progressive，有一篇文章介绍了交错扫描和逐行扫描，请大家参考！ 我在利用上述插件来压缩博客public文件夹下的资源时，发现在进行html压缩和css压缩时，出现了一些页面bug，暂未得出原因，留待后续观察，于是暂时放弃了html和css插件压缩，仅使用了gulp-uglify和gulp-imagemin来压缩js文件和图片。经优化后，博客加载速度得到了显著提升，也算是做了一个不错的优化。","link":"/利用gulp优化web页面加载速度.html"},{"title":"前端面试题记录","text":"最近在找工作，面试过程中发现自己对一些概念的叙述不是特别清楚。唉，让我自己写代码可能没有毛病，但是好像就是说不出这些概念，这无疑让自己在面试中丢了分。所以还是做下笔记吧，预祝自己在后面的面试中愈战愈勇！ 一.spa和多页应用的区别1.spa由一个外壳和页面片段组成，通常用路由跳页面，局部刷新。非spa每个页面都是一个新页面，有一套独立的html，甚至css，js，页面跳转需要重新加载资源。2.spa数据传递方便，因为页面未销毁。非spa传递参数依赖url或者Cookie，SessionStorage，LocalStorage等。3.单页面不利于seo，多页面相反。4.单页面开发成本高，依赖框架。多页面开发简单，但是重复代码多。 二.同步和异步js是单线程的，但是可以实现异步。js有主线程，也有一个任务队列。主线程的任务是同步执行的，前一个任务完成后，才执行后一个任务，而放入任务队列的是异步任务，当任务队列告诉主线程该任务可以执行了，异步任务才进入主线程执行。 三.Event Loopjs有事件轮训机制，主线程中的任务结束后，会查询任务队列，把任务队列中的第一个可执行任务压入主线程执行。 四.多页面传递数据简单的数据可以放在url的search部分，用location.search获取，复杂的数据可以存在Storage，Cookie，或者请求后台接口实现。 五.location.reload()默认从浏览器缓存中重载页面，如果传参是true，则从服务器重载。 六.angular是双向绑定还是单向数据流？都有，一般的插值表达式就是单向数据流，数据改变才引起ui改变。[(ngModel)]是双向绑定。 七.angular组件之间通信父组件通过[]属性绑定向子组件传数据，子组件通过@Input接收数据。子组件通过@Output和EventEmitter发送事件给父组件，父组件模板中以()绑定事件回调函数。 八.如何理解RESTful？RESTful（Representational State Transfer）是一种思想，很难用一两句话来解释。可以理解为：所有的资源都可以抽象为一个url，通过http请求（包括POST，GET，PUT，PATCH，DELETE）来获取资源，完成操作后通过HTTP的状态码2xx/4xx来完成状态的转换。 九.http请求的几种类型1、GET请求主要是查询数据的请求，不会修改、增加数据，不会影响资源的内容，是幂等的，即无论进行多少次操作，结果都是一样的。GET请求的参数体现在url上，能够被浏览器缓存，保存历史记录，请求的长度有限制。 2、PUT请求是向服务器端发送数据的，就像数据库的update操作一样，用来修改数据的内容，也是幂等的。 3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的create或insert操作一样，会创建新的内容。POST请求不会被浏览器缓存，也不能创建书签。POST请求参数在请求体正文中，相比GET更加安全。 4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。 5、OPTIONS：这个也是常见的请求类型，但一般不是由开发者指定，当涉及跨域时，浏览器会自动发起预检，获取目的资源所支持的请求类型。 6、注：所有的增删改查几乎都能用GET、POST实现，因此很少会选择使用PUT和DELETE请求。 十.如何理解http请求的无状态？http响应是有状态码的，但是http请求却说是无状态的，这让人很是迷惑。其实http的无状态是指：每次的请求都是独立的，与之前和之后的请求无关联，服务器中没有保存客户端的状态。但是如果加上Cookie控制，则可以进行状态管理。 十一.如何理解闭包？js函数内部的变量是不能被函数外部所引用的，闭包就是能够读取其他函数内部变量的函数。通常的形式是在函数内定义一个内部函数，内部函数引用了外部函数作用域中的变量，然后又作为外部函数的返回值被上层作用域使用，这样就形成了闭包。 十二.如何理解原型和原型链？1.任何对象都有原型proto，对象的原型指向构造函数的prototype属性。构造函数的prototype属性上有一个construtor属性，指向构造函数本身。 1234var A = function () {};var a = new A();a.__proto__ === A.prototype; // 结果为trueA === A.prototype.constructor; // 结果为true 2.js查询对象属性时，会首先从对象本身查找，如果找不到，则会顺着原型链（proto，而不是prototype）查找。常见的原型链继承写法： 1234567var Father = function () {};Father.prototype.type = 'male';Father.prototype.age = '40';var Son = function () {};Son.prototype = Object.create(Father.prototype);Son.prototype.constructor = Son;console.log(new Son().type);","link":"/前端面试题记录.html"},{"title":"呼吸灯特效","text":"今天无意间发现了一个不错的特效，就是呼吸灯效果，感觉用来放在海报周围很炫酷，用在其他地方也是不错的。 原理就是before伪元素 + animation动画 + box-shadow盒子阴影。进入demo按F12查看Elements基本能知道是怎么实现了。 呼吸灯demo","link":"/呼吸灯特效.html"},{"title":"在Linux和Windows系统中输出目录结构","text":"前言一直以来就想在写文章时，能以文本形式（而不是截图）附上项目的目录结构，今天终于知道怎么操作了，在这分享一下。 Linux首先说下Linux上输出目录结构的方法。 yum安装tree需要支持tree命令，首先是要安装tree包的。 1yum -y install tree 然后在你的项目目录下执行tree命令即可 还可以输出带颜色的结构 1tree -C Windows不需要特意安装什么，直接输入命令： 1tree /f 更多参数请参考Windows Commands / tree","link":"/在Linux和Windows系统中输出目录结构.html"},{"title":"回头再看JS模块化编程之AMD","text":"由于CommonJS采用适合服务器端的同步加载方式，这种方式不适合天生异步的浏览器端。在这种形势下，AMD（Asynchronous Module Definition，异步模块定义）应运而生。而require.js正是AMD规范下的产物，因此，我们可以直观地从require.js入手分析AMD。 require.js这是RequireJS官方下载链接，我本次测试使用的是2.3.5版本。 加载require.js使用RequireJS后，我们不用在html中手动添加蛮蛮多的script标签了，通过模块依赖的方式，RequireJS会自动创建script标签，也使得模块间依赖关系的管理变得更加方便。首先，需要在html中引入require.js，并通过data-main属性指定入口js文件 1&lt;script src=\"./js/amd/require-2.3.5.js\" data-main=\"./js/amd/main\" defer async&gt;&lt;/script&gt; 定义模块我们先不关注main.js的实现，先来看看在RequireJS中怎么定义模块。 12// name和deps都是非必选的参数，而callback可以是一个对象，或者是具有返回值的函数define([name], [deps], callback) 简单模块如果一个模块只包含一些键值对，没有任何依赖，则在define()中定义这些键值对就好了 12345678// 定义模块时，推荐不显示传入name参数，这样方便优化工具去生成。define({ name: 'simpleModule', version: '1.0.0', add: function(a, b) { return a + b; }}) 函数式模块跟上篇文章说到的IIFE是一样的道理，加入我们需要对模块做一些初始化的工作，那么就不能使用简单模块的定义方式了。函数式模块的定义方式如下： 1234567891011define(function() { // ... // 这之前可以做一些初始化的变量赋值等等... function add(a, b) { return a + b } // 最终return一个对象，暴露给调用者使用 return { add: add }}) 存在依赖的模块假设你要写一个依赖jquery的模块，那么你需要在define方法中声明依赖。 12345678define(['jquery'], function($) { function setColor(select, color) { $(select).css('color', color) } return { setColor: setColor }}) 在官网上还发现一种类似sea.js的依赖写法。 123456789define(function(require, exports, module) { var $ = require('jquery') function setColor(select, color) { $(select).css('color', color) } return { setColor: setColor }}) 我的猜想：这种写法的代码在运行时，当前模块不知道所依赖的外部模块有哪些，需要遍历所有的require关键字，找出后面的依赖。这显然是一种更牺牲性能的方法。虽然可以用var $ = require('jquery')这种“同步”的形式写代码，但终究不是一个最优的选择。 使用模块在使用模块之前，我们可以通过require.config先配置每个js的路径，方便后续代码的书写。 123456789// main.js的顶部，我定义了四个模块的pathrequire.config({ paths: { simple: './simple', jquery: '../jquery-3.3.1', funcModule: './func-module', depModule: './dep-module', }}); RequireJS调用模块的方式如下 12// callback参数列表的顺序与deps中模块的顺序一致require(deps, callback) 123456789101112require(['simple', 'jquery', 'funcModule', 'depModule'], function(simple, $, funcModule, depModule) { console.log(simple) console.log($) $('.word').css({ fontSize: '24px', color: 'blue' }) var result = funcModule.add(1,2) console.log(result) depModule.setColor('.word', 'yellow')}) 到这里我们已经掌握了RequireJS的最基本的用法了。 配置项除了paths外，RequireJS还支持很多的配置项，便于我们快速开发。完整配置可以参考RequireJS 中文网 比较常用的有baseUrl，指定了js文件的查找基路径；还有shim，用来作为垫片支持那些不符合AMD规范的js。 baseUrl经过本人测试，baseUrl的路径参考了引用require.js的入口html文件。我们看一下两种不同的文件路径配置就明白了。 首先看第一种 接着我们看一下第二种，我把requirejs.html移动到了一个html文件夹内。 这两种不同的文件路径下，baseUrl都必须参考requirejs.html的路径，否则就会发生引用404报错了。 shim有些早期的js库并不支持AMD写法，所以需要在requirejs中配置shim才可以使用它们，shim写法如下： 12345678910require.config({ shim: { &quot;underscore&quot; : { exports : &quot;_&quot;; }, &quot;jquery&quot; : { exports : &quot;$&quot;; } }})","link":"/回头再看JS模块化编程之AMD.html"},{"title":"实用网站记录（持续更新中...）","text":"有时候突然想找一个网站的网址，怎么也想不起来，也找不到，所以今天在这里记录一下一些常用的实用网站，保持持续更新，方便后续使用。 兼容性查询网站https://www.caniuse.com/ 在线cubic-bezier(贝塞尔曲线)调测网站http://cubic-bezier.com RGB颜色值与十六进制颜色码转换工具http://www.sioe.cn/yingyong/yanse-rgb-16/ 在线配色网站https://www.canva.com/colors MySQL安装教程https://jingyan.baidu.com/article/e3c78d64412ae83c4c85f5fd.html MySQL菜鸟教程http://www.runoob.com/mysql/mysql-tutorial.html GIT中文教程https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 SVG参考手册https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element SVG在线编辑器http://www.86y.org/demo/svg/ HTTP Content-Type 查询http://tool.oschina.net/commons/","link":"/实用网站记录（持续更新中...）.html"},{"title":"微信小程序的摸索之路--从demo入手揭开神秘面纱","text":"微信小程序推出已久，除了普通开发版本，如今已经支持云开发版本。框架上的选择也有很多，比较火的应该属 mpvue 和 wepy 和 taro 吧。但是我还是选择先从普通开发版本和原生语言开始入手微信小程序，然后再考虑框架的事情。 项目结构 刚接触小程序的我，一看到也是有点懵逼的。但是细心看下来，发现和其他前端框架组织的项目也是大同小异的。我们且不关注项目配置文件 project.config.json 和辅助js模块 util.js，小程序基本上由App和Page两部分组成，我们暂且称这两者都为组件吧。小程序的组件基本上由四个文件组成。 wxml 对应 html，负责模板视图；wxss 对应 css，负责样式表现；js就不用说了，负责逻辑操作；json则是负责组件相关的配置。 Demo分析小程序 demo 主要包含两个页面，首页有请求用户授权的按钮，授权后点击用户头像进入日志页面，查看登录日志。 获取用户信息该 demo 获取用户信息的思路是： 首先需要检查用户是否已经对小程序进行了个人信息授权，需要调用 12345678wx.getSetting({ success: res =&gt; { if (res.authSetting[&apos;scope.userInfo&apos;]) { // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框 ...... } }}) 如果用户第一次进入或从未授权个人信息，则不做任何默认操作，此时需要用户手动点击按钮进行授权； 根据小程序官方解释：注意：wx.authorize({scope: “scope.userInfo”})，无法弹出授权窗口，请使用 123456789101112// wxml&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt;&lt;/button&gt;// jsgetUserInfo: function(e) { console.log(e) app.globalData.userInfo = e.detail.userInfo this.setData({ userInfo: e.detail.userInfo, hasUserInfo: true }) } 用户点击该按钮时，会返回获取到的用户信息，回调的detail数据与wx.getUserInfo返回的一致。 如果已经授权过，则在 App 的 onLaunch 钩子函数中调用 getUserInfo 去获取用户信息，并在 index 页面进行显示。 这里存在一个潜在的 bug ，App 的 onLaunch 执行后，Index 页面的 onLoad 方法也会随之执行，如果此时 wx.getUserInfo 接口尚未响应完成，则 Index 不能显示出用户信息。解决的方法是在 Index 页面获取 app 实例，并在 app 实例上挂载一个回调函数，然后在 wx.getUserInfo 接口得到响应后，执行该回调函数。 12345678910111213141516171819202122232425262728// index.js// 获取应用实例const app = getApp()app.userInfoReadyCallback = res =&gt; { this.setData({ userInfo: res.userInfo, hasUserInfo: true })}// app.jswx.getSetting({ success: res =&gt; { if (res.authSetting[&apos;scope.userInfo&apos;]) { wx.getUserInfo({ success: res =&gt; { this.globalData.userInfo = res.userInfo // 如果有 index 页面指定的回调函数，则执行 if (this.userInfoReadyCallback) { this.userInfoReadyCallback(res) } } }) } }}) 存储数据和路由本地缓存该 demo 中存储日志用到了 setStorageSync ，这是一个同步存储本地缓存的方法。与之对应的同步获取本地缓存的方法是 getStorageSync 。说到同步，就不得不提到异步。本地缓存存取的异步方法分别是 getStorage 和 setStorage。小程序的本地缓存与 WebStorage 有异曲同工之妙。 123var logs = wx.getStorageSync(&apos;logs&apos;) || []logs.unshift(Date.now())wx.setStorageSync(&apos;logs&apos;, logs) 路由小程序提供的路由方法主要有以下几个： wx.redirectTo(Object object)：关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到 tabbar 页面。传入的 object 包含 url (跳转的页面的路径)，success (成功回调函数)，fail (失败回调函数），complete (接口调用结束的回调函数，无论成功或失败) 等几个属性及方法。相当于没有当前页的历史记录。 wx.navigateTo(Object object)：保留当前页面，跳转到应用内的某个页面，但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。相当于保留了当前页的历史记录。 wx.navigateBack(Object object)：关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。传入的 object 不再包含 url，而是 delta，表示后退 delta 页。 wx.reLaunch(Object object)：关闭所有页面，打开到应用内的某个页面。相当于销毁所有路由历史记录再打开新页面。 wx.switchTab(Object object)：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。","link":"/微信小程序的摸索之路-从demo入手揭开神秘面纱.html"},{"title":"小白的Linux入门篇","text":"什么是linux?大部分人应该脑海里有linux这个词的印象，但是具体是什么好像又说不出来。如果最开始你要问我，什么是linux？我会回答，linux，跟windows差不多啊，都是操作系统。其实这样说没错，Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。但是作为一名开发者而言，我们需要了解更多的信息。有两个概念需要我们来梳理一下。 linux内核版本Linux内核版本就是linux的核心版本，Linux内核的主要模块（或组件）分以下几个部分：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信，以及系统的初始化（引导）、系统调用等。其实，比较简单的说法就是，linux内核版本是最官方、最核心的版本。内核版本由官网进行发布。 linux发行版本一些组织或企业，基于linux内核做了一些上层应用和工具的定制开发，形成了各种各样的发行版本。现在比较流行的发行版本主要分为两大派系redhat和debian。redhat, CentOS, fedora, SuSE, gentoo是redhat分支，debian, ubuntu等是debian分支。比较公认的说法是，服务器领域尽量选Redhat，非服务器领域还是要选debian分支如ubuntu。服务器的要求是安全，稳定，因此越少的图形界面相对来说是更优的选择。 linux应用领域服务器领域linux具备良好的稳定性，可靠的安全性，完善的网络功能，跨平台的硬件支持，多用户多任务管理，丰富的生态支持，是服务器领域的不二之选。 嵌入式领域Linux在嵌入式领域可谓是大展身手，如移动设备、嵌入式板卡、物联网、智能家居、消费级设备、无人机、机器人、可穿戴设备和汽车等，都有涉及到linux系统。 linux虚拟机安装看到这一点，很多人会感到疑惑，为什么不直接装linux系统，却要装虚拟机？虚拟机可以让你在windows下使用linux环境，非常适合新手学习使用。VMware是一款功能强大的桌面虚拟计算机软件，提供用户可在桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的解决方案。在VMware的版本选择上，推荐使用VMware8，因为作为初学来说，太高的版本我们用不上，还可能会让自己的电脑变得很卡。在百度搜索，就可以下载到VMware8。 安装完成可以选择汉化工具，做一下汉化，便于我们使用。","link":"/小白的Linux入门篇.html"},{"title":"干货！Git 如何使用多个托管平台管理代码","text":"考虑到github不能免费创建私有仓库原因，最近开始在使用码云托管项目，这样避免了连接数据库的用户密码等信息直接暴露在公共仓库中。今天突然想到一个点，就是能不能同时把代码推送到github和码云上呢？答案是可以的。 背景首先，我们在开始一个项目时，在本地写了一些代码，需要同时托管到github和码云（gitee）上。这个时候我们要怎么办呢？请接着看。 实现方法添加密钥对在C:\\Users\\robin.ssh目录下运行git bash 1234// 这个是给github生成的ssh-keygen -t rsa -C \"1148121254@qq.com\"// 这个是给码云生成的ssh-keygen -t rsa -C \"cumtrobin@163.com\" 生成后自行命名管理，这里不再赘述。接着把公钥分别放在github和码云上。私钥可以用config文件管理 12345678910111213# 配置github.comHost github.com HostName github.com IdentityFile C:\\\\Users\\\\robin\\\\.ssh\\\\id_rsa_github PreferredAuthentications publickey User cumtRobin# 配置gitee.comHost gitee.com HostName gitee.com IdentityFile C:\\\\Users\\\\robin\\\\.ssh\\\\id_rsa_gitee PreferredAuthentications publickey User Tusi 接着我们测试一下 12ssh -T git@github.comssh -T git@gitee.com 成功则会得到这样的反馈 创建仓库首先是在github和码云上分别创建一个仓库。这个玩过github的都知道，不细说。 接着在本地项目根目录创建git仓库 1git init 本地与remote关联要把两个remote仓库与本地git仓库关联起来，我们直接来运行 1234// 添加github的远程库git remote add origin git@github.com:cumtRobin/BlogFrontEnd.git// 添加码云的远程库git remote add gitee git@gitee.com:tusi/BlogFrontEnd.git 然后我们运行git remote查看添加的远程库列表 1234git remote// 得到以下值origingitee 说明已经添加成功，接着我们分别查看git status，会看到本地有很多文件待提交，接着git add, git commit，最后git push的时候要注意分开push 1234// push到github主分支git push origin master// push到gitee主分支git push gitee master 虽然麻烦了一点，需要push两次，但是目的是初步达成了。如果想要一次性push解决，那也不是没有办法。 一次性push为了避免引起歧义，这里先将origin，gitee的remote库删除 12git remote rm origingit remote rm gitee 重新添加remote 1git remote add all git@github.com:cumtRobin/BlogFrontEnd.git 可以看到，我其实是添加的github的远程库，只不过把它的名字叫做all。接着我们把码云上的remote库也关联起来。 1git remote set-url --add all git@gitee.com:tusi/BlogFrontEnd.git 这样操作以后，就可以运行一条push命令了 1git push all --all 有人说可以改.git/config文件实现。其实刚才上面的命令修改的就是config文件，但是本人建议，多练练命令行，这样也会加深对git的理解。这时候我们再查看一下.git/config文件。可以看到remote all下面是有两个url的。 12345678910[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;all&quot;] url = git@github.com:cumtRobin/BlogFrontEnd.git url = git@gitee.com:tusi/BlogFrontEnd.git 学会了两个托管平台的配置，那使用更多的托管平台也就不难实现了。 ps：再分享一个小技巧，由于我在生成ssh密钥时，加了passphrase，导致我每次push都要输入密码，很烦人。 其实，只要重置一下这个passphrase就可以了。 12345// 进入到.ssh目录，运行git bashssh-keygen -p// 再输入密钥名，如id_rsa_github，先输入旧密码，然后一路回车即可，多个密钥重复此操作即可。 2019-04-18 补充 git pull 的细节 因为都是从本地 push 代码到远程仓库，很久没有从远程仓库拉取代码了，今天不小心在 github 上改了仓库中的 readme 文件，导致和 gitee 不同步。使用 git pull 报错，慌的一批。 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=all/&lt;branch&gt; master 原来是要使用下面这条命令才行。 1234$ git pull all masterFrom github.com:cumtRobin/BlogFrontEnd * branch master -&gt; FETCH_HEADAlready up to date. 上面的 all 是指 remote ，即远程仓库，master 是指分支名，master 即主干分支。","link":"/干货！Git-如何使用多个托管平台管理代码.html"},{"title":"理解css中的px, em, rem","text":"px px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 em em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 ps：em会继承父级元素的字体大小。 rem rem是CSS3新增的一个相对单位。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。 这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。 12// 兼容写法p {font-size:14px; font-size:.875rem;}","link":"/理解css中的px, em, rem.html"},{"title":"微信小程序自定义tabBar","text":"本文分享一下微信小程序自定义tabBar的几种实现方式。 模拟的tabBar页面（不推荐）使用策略 app.json不配置tabBar，用普通page来代替tabbar页面，暂且称之为模拟的tabbar页面。 每个模拟的tabbar页面都需要引入自定义tabbar组件。 自定义的tabbar组件写法如下： /components/index-tabbar/index.json 1234567{ &quot;component&quot;: true, &quot;usingComponents&quot;: { &quot;van-tabbar&quot;: &quot;vant-weapp/tabbar/index&quot;, &quot;van-tabbar-item&quot;: &quot;vant-weapp/tabbar-item/index&quot; }} /components/index-tabbar/index.wxml 12345678&lt;cover-view class=\"container\"&gt; &lt;van-tabbar active=\"{{ active }}\" bind:change=\"onChange\"&gt; &lt;van-tabbar-item name=\"index\" icon=\"home-o\"&gt;首页&lt;/van-tabbar-item&gt; &lt;van-tabbar-item name=\"category\" icon=\"label-o\"&gt;分类&lt;/van-tabbar-item&gt; &lt;van-tabbar-item name=\"msgs\" icon=\"comment-o\"&gt;留言&lt;/van-tabbar-item&gt; &lt;van-tabbar-item name=\"my\" icon=\"user-o\"&gt;我的&lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt;&lt;/cover-view&gt; /components/index-tabbar/index.js 123456789101112131415Component({ properties: { active: { type: String, value: 'index' }, }, methods: { onChange(event) { wx.redirectTo({ url: `/pages/${event.detail}/index`, }) } }}) 模拟的tabbar页面写法如下： /pages/home/index.json 12345{ &quot;usingComponents&quot;: { &quot;index-tabbar&quot;: &quot;/components/index-tabbar/index&quot; }} /pages/home/index.wxml 1234&lt;view class=\"container\"&gt; &lt;text&gt;首页&lt;/text&gt; &lt;index-tabbar active=\"index\"&gt;&lt;/index-tabbar&gt;&lt;/view&gt; 跳转页面使用wx.redirectTo 总结由于wx.redirectTo跳转页面是跳转的普通页面，页面渲染也自然会导致自定义的tabbar组件重新渲染，所以会出现底部tabbar闪一下的视觉体验，很尴尬。 Component伪装Page（还不错）使用策略将上述4个模拟的tabBar页面换成组件写法，然后根据条件进行wx:if控制。 改造首页，分类，留言，我的，将其由页面改为组件 /pages/home/index.json 123{ &quot;component&quot;: true} /pages/home/index.wxml 123&lt;view&gt; &lt;text&gt;首页&lt;/text&gt;&lt;/view&gt; /pages/home/index.js 1Component({}) index-tabbar组件改造 /components/index-tabbar/index.wxml 1234567891011121314&lt;cover-view class=\"container\"&gt; &lt;van-tabbar active=\"{{ active }}\" bind:change=\"onChange\"&gt; &lt;van-tabbar-item wx:for=\"{{panels}}\" wx:for-index=\"index\" wx:for-item=\"item\" wx:key=\"{{index}}\" name=\"{{item.name}}\" icon=\"{{item.icon}}\" info=\"{{item.badge}}\"&gt; {{item.label}} &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt;&lt;/cover-view&gt; /components/index-tabbar/index.js 1234567891011121314151617Component({ properties: { active: { type: String, value: 'home' }, panels: { type: Array, value: [] }, }, methods: { onChange(event) { this.triggerEvent('changeTab', event.detail) } }}) 入口页index改写成如下 /pages/index/index.json 123456789{ &quot;usingComponents&quot;: { &quot;index-tabbar&quot;: &quot;/components/index-tabbar/index&quot;, &quot;home-panel&quot;: &quot;../home/index&quot;, &quot;category-panel&quot;: &quot;../category/index&quot;, &quot;msgs-panel&quot;: &quot;../msgs/index&quot;, &quot;my-panel&quot;: &quot;../my/index&quot; }} /pages/index/index.wxml 1234567&lt;view class=\"container\"&gt; &lt;home-panel wx:if=\"{{activeTab == 'home'}}\"&gt;首页&lt;/home-panel&gt; &lt;category-panel wx:if=\"{{activeTab == 'category'}}\"&gt;分类&lt;/category-panel&gt; &lt;msgs-panel wx:if=\"{{activeTab == 'msgs'}}\"&gt;留言&lt;/msgs-panel&gt; &lt;my-panel wx:if=\"{{activeTab == 'my'}}\"&gt;我的&lt;/my-panel&gt; &lt;index-tabbar active=\"{{activeTab}}\" panels=\"{{panels}}\" bind:changeTab=\"onTabChange\"&gt;&lt;/index-tabbar&gt;&lt;/view&gt; /pages/index/index.js 12345678910111213141516Page({ data: { activeTab: 'home', panels: [ { name: 'home', icon: 'home-o', label: '首页' }, { name: 'category', icon: 'label-o', badge: '5', label: '分类' }, { name: 'msgs', icon: 'comment-o', badge: '99+', label: '留言' }, { name: 'my', icon: 'user-o', label: '我的' } ] }, onTabChange(event) { this.setData({ activeTab: event.detail }) }}) 效果如下： 总结由于是通过wx:if控制组件的创建和销毁，是局部更新，所以不会导致底部tabbar的重新渲染，所以底部闪一下的问题就解决了。缺点我想是如果频繁切换tab可能导致wx:if的渲染开销大吧。 官方自定义tabBar官方也提供了自定义tabbar的方法，见自定义 tabBar。 基础库 2.5.0 开始支持，低版本需做兼容处理。","link":"/微信小程序自定义tabBar.html"},{"title":"理解html中script标签的defer与async属性","text":"前言经常会在一些地方看到一些&lt;script&gt;标签带上了defer和async，总是搞不清楚两者的具体区别，于是想记录下来。 从单词语义上来，defer代表延迟，async代表异步。那么我们就有一个基本的概念了。然后我们慢慢分析。 如果没有defer和async&lt;script&gt;标签如果没有带上defer或async属性的话，浏览器会立即加载并执行标签内的脚本，意思大概是不等待后续载入的文档元素，读到这个&lt;script&gt;标签就加载并执行。 如果有deferdefer的意思是延迟，也就是说延迟执行，除了这一点，加载的过程是异步的。那么就很好解释了，当遇到 1&lt;script defer&gt; 这种标签时，会开始加载script标签内容，但是不会阻塞后续文档元素的渲染，待所有页面元素解析完成后，DOMContentLoaded 事件触发之前执行这个script标签的代码。 如果有asyncasync就是sync的反义词，代表异步，也就是说异步加载和执行。所以，当遇到 1&lt;script async&gt; 这种标签时，加载和执行脚本的同时不会阻塞其他文档元素的渲染。 多个标签的情况还有一点要注意的就是，多个async标签是不会相互影响的，谁先加载完，谁就先执行了。而多个defer标签是异步加载，但是最后执行的顺序是根据其在页面上的顺序来决定的。 现在是不是觉得豁然开朗了呢？","link":"/理解html中script标签的defer与async属性.html"},{"title":"自定义滑块Range Slider","text":"原生的组件虽然长得丑，但是提供给我们的能力是很多的。原生的事件以及属性，这些是某些UI框架不能给我们的。所以，基于原生的一些组件来做一些定制化修改是有必要的。首先，我们来看一个常用的滑块组件。 场景我在一个视频类demo中，使用到了滑块组件（也就是range类型的input组件）。 1&lt;input type=\"range\" value=\"{{currentTime}}\" min=\"0\" max=\"{{duration}}\" step=\"1\" (input)=\"progressChange($event)\"&gt; 未做定制的效果如下： 用到input的有两处，一个是视频的进度条，一个是音量条。不能说这个样式很丑，但是还有美化的空间。那么我们如何来修改input默认的样式呢？ 自定义样式input组件主要由两部分组成，轨道和滑块，它们都是伪元素。我们只要针对这两个伪元素来做试探性修改css就可以看到效果了。 123456789// 轨道的伪元素，分别对应chrome，firefox，IE浏览器。// ::-webkit-slider-runnable-track// ::-moz-range-track// ::-ms-track// 滑块的伪元素，分别对应chrome，firefox，IE浏览器。// ::-webkit-slider-thumb// ::-moz-range-thumb// ::-ms-thumb 去除浏览器的默认样式每个浏览器对range类的input有不一样的默认样式，我们首先来去掉这种默认样式。 1234567891011input[type=range] { // 去除浏览器默认的样式 -webkit-appearance: none; -moz-appearance: none; width: 300px; border-radius: 10px; &amp;:focus { // 去除落焦时的外边框效果 outline: none; }} 修改轨道css样式的修改方式如下所示，这里只给出chrome的修改内容给大家参考，具体想要的样式效果当然由自己而定。 12345input[type=range]::-webkit-slider-runnable-track { height: 6px; border-radius: 10px; /*将轨道设为圆角的*/ background: #ee2828;} 修改滑块css废话不多说，上代码。 12345678910input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; -moz-appearance: none; width: 10px; height: 10px; border-radius: 50%; position: relative; top: -2px; background: #fff;} 修改完毕，我们来看一下效果图。感觉还不错吧，加以修改，相信能做出更美的效果。 放一个demo链接，大家自行查阅。","link":"/自定义滑块Range Slider.html"},{"title":"解决Chrome的表单自动填充问题","text":"一般的浏览器都会默认开启一个表单自动填充的功能。这给很多用户带来了方便。但是对于项目开发者来说，有时候这就是噩梦。对安全性有考虑的项目，应该都会考虑到禁用这种自动填充的功能。否则，一个用户登录后，浏览器记住了用户名和密码。当另一个人使用这台电脑时，他肯定不用输入什么，就可以登入别人的账号，这可是很危险的事情。 问题背景当我使用原始的表单成功登录一次后时，再次打开浏览器，什么都没有输入，就出现了这样的现象。 浏览器帮忙记住了用户名和密码。有的人会说，这个OK啊，让用户把浏览器的填充表单的功能禁止掉不就行了？ what？你指望让用户来完成本应该由你的程序完成的事情？领盒饭走人吧！ so，怎么解决这个问题呢？ 解决过程首先想到的是通过autocomplete=”off”属性来禁止自动填充，然而发现好像没有起到作用。 接下来我查到的信息是，浏览器会寻找表单中的输入框，自动填充。 12&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;password&quot;&gt; 灵机一动，我想到在我的真实表单输入框前面放一个隐藏的输入框，如果这个隐藏的输入框代替真实的输入框被浏览器填充，那么问题不久解决了吗。于是，代码变成这样的。 12345678910111213141516171819&lt;el-form :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot; ref=&quot;loginForm&quot; class=&quot;login-form&quot; autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot; style=&quot;display:none;&quot; autocomplete=&quot;off&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;display:none;&quot; autocomplete=&quot;off&quot;/&gt; &lt;div class=&quot;formGroup&quot;&gt; &lt;label class=&quot;login-label&quot;&gt;用户名&lt;/label&gt; &lt;el-form-item prop=&quot;account&quot;&gt; &lt;el-input class=&quot;login-input&quot; type=&quot;text&quot; v-model=&quot;loginForm.account&quot; auto-complete=&quot;off&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/div&gt; &lt;div class=&quot;formGroup&quot;&gt; &lt;label class=&quot;login-label&quot;&gt;密码&lt;/label&gt; &lt;el-form-item prop=&quot;password&quot;&gt; &lt;el-input class=&quot;login-input&quot; type=&quot;password&quot; v-model=&quot;loginForm.password&quot; auto-complete=&quot;off&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/div&gt; &lt;div class=&quot;formGroup&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;login-btn&quot; id=&quot;btnLogin&quot; @click=&quot;login&quot; v-loading=&quot;logining&quot;&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/el-form&gt; 再次尝试，发现打开登录页后，浏览器没有填充我的el-input了，顿时感觉轻松了下来。然而，当我点击密码框的时候，出现了密码列表。。。坑爹啊！ 还能怎么办，接着寻找解决方案吧！接下来找了很多方法，尝试后都不是有效的。 于是我尝试先去掉自动填充后的屎黄色。。。 这个填充色是由浏览器伪类input:-webkit-autofill来实现的 于是我加了这些代码 123input:-webkit-autofill { background-color: #fff;} 但是仍然没有去掉浏览器自带的填充背景色。我就想是不是没有加!important。最后加上了也没有用。看来并不能覆盖掉自带的这个样式属性啊。 在网上搜索后，发现了一个神解决方法，使用盒子阴影来盖住屎黄色，真的可以做到。为这位网友的机智点赞！ 1234input:-webkit-autofill { box-shadow: 0 0 0px 1000px white inset; -webkit-box-shadow: 0 0 0px 1000px white inset;} 虽然解决了这个屎黄色背景的问题，但是没有从根本上解决我的需求。接下来的寻找答案的过程中，发现了一个奇妙的解决方案。 1&lt;el-input class=&quot;login-input&quot; type=&quot;password&quot; v-model=&quot;loginForm.password&quot; auto-complete=&quot;new-password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt; 就是这么简单，去掉了自动填充的烦人功能。说是autocomplete除了on，off以外的值就可以做到。但是我发现除了new-password，没有其他的值可以有效，Amazing！","link":"/解决Chrome的表单自动填充问题.html"},{"title":"通过TortoiseGIT怎么把本地项目上传到GitHub？","text":"在本地修改代码，没有一个修改日志记录，确实很不方便。所以想着把本地的代码放在github上面。虽然在公司有大神搭建好的git服务器，按着流程commit, push, merge request走一遍就行了，但是自己是一知半解的。所以自己弄一遍流程是有必要的。 1.明确一下自己的需求暂时不考虑多人协作的情况了，先把自己的代码弄上去再说吧。欲速则不达，一步一步来吧。 2.创建GitHub仓库 点击New repository创建仓库，然后把相关信息填一下就OK了 3.创建本地仓库在自己的项目文件夹，点击右键，选择GIT Create respository here 然后右键选择Settings进行设置。主要是remote里面的设置项。 Remote的名字一般是origin。URL是你的GitHub仓库对应的URL，复制粘贴一下就好了。Putty是你本地的私钥，找到对应的文件。设置完后选择Add New，在弹出的确认框选择‘否’就好。 4.把本地代码提交到GitHub第一步，选择GIT commit提交代码。 填好必要的提交信息，选择需要提交的文件，然后点击commit commit之后记得一定要将代码push到远程服务器端。操作就是GitPush。 然后在GitHub上面就能看到自己提交的代码了，也可以看到提交的记录。","link":"/通过TortoiseGIT怎么把本地项目上传到GitHub？.html"},{"title":"解决npm install卡住不动的小尴尬","text":"遇到的问题1npm install -g @angular/cli 安装angular cli工具时，发现进度条一直卡住不动，相信很多朋友也遇到过。原因应该是国内的网络连接npm速度较慢，甚至很多东西都无法下载安装。那么如何解决这个问题呢？ 方案一：安装cnpm镜像这个是比较常用的方法，我首先也是使用了这个方法。cnpm的安装方法，参考http://npm.taobao.org/ 1npm install -g cnpm --registry=https://registry.npm.taobao.org cmd输入以上命令就可以了，然后输入 1cnpm install -g @angular/cli 后面的操作跟不使用镜像的操作是差不多的。但是笔者在后续使用过程中遇到了一些问题，运行ng eject后发生了一些错误，所以放弃了这个方案，采用了方案二。 方案二：使用代理registry在网上查阅了一些资料后，决定使用代理的方式，方法也很简单，就是 1npm config set registry https://registry.npm.taobao.org 然后后续的install等命令还是通过npm运作，而不是cnpm。 有点小强迫症的我还是喜欢npm install","link":"/解决npm install卡住不动的小尴尬.html"},{"title":"ES5，ES6的简要说明及浏览器支持性总结","text":"前端开发离不开javascript语言，而与之密切联系的就是ECMAScript。 ##1.什么是ECMAScript？ 摘自百度百科：ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。下文中就以ES和JS来简称。简单说，ES是JS的一种语言标准。ES正在不断发展，目前我们接触比较多的就是ES5和ES6（ES6也叫ES2015）了。 ##2.ES5的简单介绍 ###2.1 首先说一下兼容性问题 从caniuse上面可以查询到，ES的兼容性概览。下面就主要浏览器进行说明：IE：可以看到IE6，IE7是完全不支持的。而IE8是只支持一些内容，参考引用4，IE9是大部分支持，支持度参考引用2。Chrome：Chrome 23版本之后就是完全支持的了。1922版本有不兼容的地方，参考引用1。Firefox：Firefox 21版本之后就是完全支持的了。420版本有不兼容的地方，参考引用1。其他浏览器参考caniuse：【1】Does not support parseInt() ignoring leading zeros.【2】Does not support Strict mode.【3】Does not support zero-width chars in identifiers &amp; Immutable undefined.【4】IE8 has virtually no ES5 support, but does support Object.defineProperty, Object.getOwnPropertyDescriptor, JSON parsing &amp; Property access on strings. ###2.2 ES5有哪些新特性呢？ ####2.2.1 严格模式 严格模式是ECMAScript 5的新特性，它允许你把整个程序，或者某个函数，放置在“严格”的操作语境中。使用方法是在作用域开头加上这样一条语句。 1&quot;use strict&quot;; ####2.2.2 Object新增方法 （1）Object.create() 创建一个具有指定原型且可选择性地包含指定属性的对象 1Object.create(__proto__, [ propertiesObject ]) （2）Object.getPrototypeOf() 返回该对象的原型 1Object.getPrototypeOf(object) （3）Object.getOwnPropertyNames() 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组 1Object.getOwnPropertyNames(object) （4）Object.keys() 返回一个由给定对象的自身可枚举属性组成的数组。而使用for-in 循环时，还会枚举其原型链上的属性。 1Object.keys(object) （5）Object.defineProperty() 在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象 1Object.defineProperty(object, property, descriptor) （6）Object.defineProperties() 在一个对象上添加或修改一个或者多个自有属性，并返回该对象 1Object.defineProperties(object, properties) （7）Object.getOwnPropertyDescriptor() 返回对象上一个自有属性对应的属性描述符（不需要从原型链上进行查找的属性）。如果指定的属性存在于对象上，则返回其属性描述符（property descriptor），否则返回 undefined 1Object.getOwnPropertyDescriptor(object, property) （8）Object.seal() 密封一个对象，并返回被密封后的对象。密封对象不能添加新的属性，不能删除已有属性，以及不能修改已有属性的enumerable、configurable、writable，但可以修改已有属性的value 1Object.seal(object) （9）Object.isSealed() 判断一个对象是否是密封的 1Object.isSealed(object) （10）Object.freeze() 冻结一个对象，比seal更严格，连value都不能修改 1Object.freeze(object) （11）Object.isFrozen() 判断一个对象是否冻结 1Object.isFrozen(object) （12）Object.preventExtensions() 让一个对象变成不可扩展的，也就是永远不能再添加新的属性 1Object.preventExtensions(object) （13）Object.isExtrensible() 判断一个对象是否是可扩展的 1Object.isExtrensible(object) （14）prototype.isPrototypeOf(object) 确定一个对象是否存在于另一个对象的原型链中 1234function Rectangle() {}var rec = new Rectangle();document.write(Rectangle.prototype.isPrototypeOf(rec)); （15）object.propertyIsEnumerable(propertyName) 确定指定的属性是否可枚举 1234var a = {};a.b = 3;console.log(a.propertyIsEnumerable(&apos;b&apos;));// 输出是true ####2.2.3 Array新增方法 （1）Array.isArray() 用于确定传递的值是否是一个 Array 12Array.isArray([1, 2, 3]); // true （2）Array.prototype.every(callback[, thisArg]) 测试数组的所有元素是否都通过了指定函数的测试。callback：用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留thisArg：可选。执行 callback 时的用于 this 的值。 1234567function isBigEnough(element, index, array) { return (element &gt;= 10);}var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true （3）Array.prototype.filter(callback[, thisArg]) 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。即是过滤函数。 123456var a = [1, 2, 3];var b = a.filter(function(element) { return element &gt; 2;});console.log(b);//输出 [3] （4）Array.prototype.forEach(callback[, thisArg]) 对数组的每个元素执行一次提供的函数。 1234const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr.forEach(function(element) { console.log(element);}); （5）Array.prototype.indexOf(searchElement, fromIndex) 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1 12let a = [2, 9, 7, 8, 9]; a.indexOf(2); // 0 （6）Array.prototype.lastIndexOf() 返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 123var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3 （7）Array.prototype.map() 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 123var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] （8）Array.prototype.reduce() 从左到右为数组中的每一个元素依次执行callback函数，返回累计处理的结果。 1234var total = [0, 1, 2, 3].reduce(function(sum, value) { return sum + value;}, 0);// total is 6 （9）Array.prototype.reduceRight() 与Array.prototype.reduce() 的执行方向相反。（10）Array.prototype.some() 测试数组中的某些元素是否通过由提供的函数实现的测试。every()是全部元素满足条件，some()只要任意一个元素满足条件。 ####2.2.4 String新增方法 （1）String.prototype.trim() 会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 12var orig = &apos; foo &apos;;console.log(orig.trim()); // &apos;foo&apos; ####2.2.5 Date新增方法 （1）Date.now() 返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。 ####2.2.6 JSON对象 （1）JSON.parse() 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。 1234let a = &apos;{&quot;b&quot;: 3}&apos;;let c = JSON.parse(a);console.log(c);// {b: 3} （2）JSON.stringify() 将一个JavaScript值(对象或者数组)转换为一个 JSON字符串。 1234let dd = {bb: 3};let cc = JSON.stringify(dd);console.log(cc);// &apos;{&quot;bb&quot;:3}&apos; 上述就是ES5的主要新特性概括，下面我们再看看ES6有哪些新特性。 ##3. ES6（ES2015）的简要说明 ES6各个特性的支持情况比较细，可根据具体特性查询caniuse ###3.1 ES6新特性 参考文档：http://es6.ruanyifeng.com/#docs/intro（ECMAScript 6 入门）下面简单说一些比较常见的ES6用法（1）let 用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。实际上为 JavaScript 新增了块级作用域。 123456{ let a = 10; var b = 1;}a; // ReferenceError: a is not defined.b; // 1 （2）const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. （3）数组的解构赋值 12let [a, b, c] = [1, 2, 3];// let a=1,b=2,c=3; （4）对象的解构赋值 123let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };foo // &quot;aaa&quot;bar // &quot;bbb&quot; （5）箭头函数 =&gt; 1var f = v =&gt; v; 等效于 123var f = function(v) { return v;}; （6）Promise对象是异步编程的一种解决方案。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。基本用法是，创建一个Promise实例， 123456789const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }}); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) { // success}, function(error) { // failure}); （7）Class语法：包括constructor，get，set等经典函数方法。（8）Module语法：包括import，export等经典模块引入和导出写法。","link":"/ES5，ES6的简要说明及浏览器支持性总结.html"},{"title":"vue项目中引入iconfont","text":"背景对于前端而言，图标的发展可谓日新月异。从img标签，到雪碧图，再到字体图标，svg，甚至svg也有了类似于雪碧图的方案svg-sprite-loader。雪碧图没有什么好讲的了，只是简单地利用了background-position来做图标定位。今天咱们先聊聊怎么使用字体图标和svg图标。其实字体图标也不陌生了，bootstrap，font-awesome，element-ui等UI库都基本标配了字体图标。 简单说下原理unicode预留了E000-F8FF范围作为私有保留区域，这个区间的unicode码非常适合做字体图标，前端根据unicode码就能显示对应的图标。 vue项目引入iconfont1. 在iconfont新建项目 注：这里修正一下，前缀应该是test-icon-。 2. 添加图标至项目 3. 使用iconfontUnicode方式（不推荐）在线使用 index.scss中引入在线字体 123456789@font-face { font-family: &apos;iconfont&apos;; /* project id 1254715 */ src: url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.eot&apos;); src: url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.woff2&apos;) format(&apos;woff2&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.woff&apos;) format(&apos;woff&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.ttf&apos;) format(&apos;truetype&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.svg#iconfont&apos;) format(&apos;svg&apos;);} 页面中使用 使用时很不友好，使用的是unicode码表示，使用图标还必须去iconfont项目去查询下unicode码。 12345678&lt;template&gt; &lt;div&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ee;&lt;/i&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ed;&lt;/i&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ec;&lt;/i&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7eb;&lt;/i&gt; &lt;/div&gt;&lt;/template&gt; 效果图如下： 本地使用有时候网络不是那么给力的，或者是内网环境，那么就不要考虑用在线引用的方式了。 本地使用需要先将字体库下载并放到项目中。 在全局样式文件中定义如下代码 1234567891011121314151617@font-face { font-family: &quot;iconfont&quot;; src: url(&apos;../fonts/iconfont.eot&apos;); /* IE9*/ src: url(&apos;../fonts/iconfont.eot#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;../fonts/iconfont.woff&apos;) format(&apos;woff&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.woff2&apos;) format(&apos;woff2&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;../assets/fonts/iconfont.svg#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */}.iconfont { font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;} 使用方式 与在线引用方式是一样的，都是使用unicode码去展示图标。 123&lt;template&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ee;&lt;/i&gt;&lt;/template&gt; 总结 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 Font class方式（较友好）一种更友好的封装，类似于font-awesome，我们只要使用class，就可以调用图标了。其原理就是利用before伪元素来显示图标。 在线使用超级简单，只要在线生成代码，引用在线的css文件即可使用。 在index.html中引用它。 1&lt;link rel=\"stylesheet\" href=\"//at.alicdn.com/t/font_1261797_48wm20jf8z.css\"&gt; 项目中就可以使用字体图标了。 1234&lt;template&gt; &lt;i class=\"iconfont cl-icon-fold\"&gt;&lt;/i&gt; &lt;i class=\"iconfont cl-icon-delete-solid\"&gt;&lt;/i&gt;&lt;/template&gt; 本地使用与unicode方式类似，下载代码到本地。因为我是用scss管理样式的，需要在下载的代码中提取出关键部分。除了引用字体库，还要将其中的iconfont.css中定义的before伪元素全部复制到自己的scss文件中。 12345678910111213141516171819202122232425262728293031323334@font-face { font-family: &quot;iconfont&quot;; src: url(&apos;../fonts/iconfont.eot&apos;); /* IE9*/ src: url(&apos;../fonts/iconfont.eot#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;../fonts/iconfont.woff&apos;) format(&apos;woff&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.woff2&apos;) format(&apos;woff2&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;../assets/fonts/iconfont.svg#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */}.iconfont { font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;}// 列了一部分举例.cl-icon-user:before { content: &quot;\\e64b&quot;;}.cl-icon-video:before { content: &quot;\\e66b&quot;;}.cl-icon-pause:before { content: &quot;\\e7bd&quot;;}.cl-icon-orgnazation:before { content: &quot;\\e61b&quot;;} 总结 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 建议由于加了新的图标需要重新在iconfont.cn重新生成代码，所以这种方式也不算很方便，但是相对于unicode还是高级不少。根据我的经验，建议在调试时，不要每次图标更新，就下载到本地更换。应该先使用在线使用的方式，调试完毕确认无误后，再下载到本地使用，这样对于效率提升有很大帮助。 symbol方式（支持多色图标）svg的symbol提供了类似于雪碧图的功能，让svg的使用变得更简单，也可以满足做图标系统的需求。可以参考张大大博客了解更多关于svg symbol的知识。 在线使用首先在iconfont项目中选择symbol方式，并在线生成js代码 然后在index.html中引入这个js文件 1&lt;script src=\"//at.alicdn.com/t/font_1254715_oewlgci0ut.js\"&gt;&lt;/script&gt; 这个js的作用是在文档中生成svg symbol 最后就可以在页面中通过use标签使用svg图标了。xlink:href的值设置为对应的symbol的id即可。 123&lt;svg aria-hidden=\"true\"&gt; &lt;use xlink:href=\"#test-icon-word-ext\"&gt;&lt;/use&gt; &lt;/svg&gt; 效果如下： 多色图标还是酷！ 本地使用本地使用也是一样的道理，主要是依赖这个在线生成的js文件，将在线js文件的链接在浏览器空标签中打开，就可以得到其内容，然后复制内容，自己命名一个js文件，并把它放在本地项目静态资源目录下，引用即可。 1&lt;script src=\"./static/js/symbols.js\"&gt;&lt;/script&gt; 图标自动管理（必看）即使使用了symbol方式，当设计小姐姐新增图标时，我们还是无法避免重新生成图标代码。那么有没有更优雅的解决方案呢？答案是有的。svg-sprite-loader + require.context。 svg-sprite-loader网上已经有太多文章了。 关于require.context，我倒是有一点自己的理解。请查看一张图带你了解webpack的require.context。 总结 支持多色图标了，不再受单色限制。 支持丰富的css属性进行定制。 兼容性较差，支持 ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png。","link":"/vue项目中引入iconfont.html"},{"title":"回头再看JS模块化编程","text":"什么是模块？我们可能要从需求上出发进行理解，当web应用的规模变得越来越大，业务变得越来越复杂时，我们需要将一些函数分门别类，在分类的基础上对函数进行封装，这就形成了模块。下面看一下js模块的一些形式。 对象模块假如我们有多个函数，想作为一个模块使用，最原始的做法就是把这几个函数全部放在一个js文件，通过文件的形式来对js进行划分模块。 12345678// my_module.jsfunction add(a, b) { return a + b;}function multiply(a, b) { return a * b;} 然而这样的做法会污染全局环境，引用这个js后，window对象就会多了两个方法。那么如何减少这种对全局环境的污染呢？想到的最简单的一个办法就是，把这几个函数都放在一个对象中，只暴露一个对象。 12345678910// my_module.jsvar MyModule = { add: function (a, b) { return a + b; }, multiply: function (a, b) { return a * b; }} IIFEIIFE（immediately invoked function expression），也就是立即执行函数表达式。假设有这样一个场景，你的模块需要定义默认参数，而你又希望这个默认参数不被外界所改变，那么使用对象模块的方式就没有办法做到了，因为这个对象已经暴露在全局环境中。那么如何能隔离作用域呢？聪明的你已经想到了函数，对的，函数可以做到。我们通过IIFE为window挂载了setColor方法。 12345678(function(global) { var default_option = { color: 'blue' } global.setColor = function(id, colorValue) { document.getElementById(id).style.color = colorValue || default_option.color }})(this) 这里的default_option就不会暴露在全局环境中，你可以尝试一下在控制台console.log(window.default_option)，得到的就是undefined。 CommonJS引用百度给出的定义 CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。 CommonJS提供的模块方案认为，一个js就是一个模块，我们经常用到的变量和函数有global，module，exports，require。global是nodejs环境的全局对象，类似与浏览器环境的window，也是根对象，任何在全局环境下定义的变量或函数都是global的属性或方法，global涉及很多东西，这里不再赘述。而module是模块对象，exports包含该模块要导出的变量或函数，require是导入模块的方法。我们首先写两个简单的js来认识它们。 12345678910// a.jsmodule.exports.add = function (a, b) { return a + b;}// b.jsvar a = require('./a.js');var result = a.add(1, 2);console.log(result); // 输出3 这是最简单的模块写法，a.js通过exports导出add函数，而b.js通过require导入a模块，便可以调用a模块的add函数。 module那么我们先来看看module这个对象。在b.js中我们console.log(module)，则会打印出模块b的信息。 可以看到，模块b的children里有模块a，说明模块b引用了模块a。我们再观察一下模块a，修改a.js的代码如下，再运行b.js 12345console.log(module)module.exports.add = function (a, b) { return a + b;} 可以看到，模块a的parent指向模块b，是因为执行的是b.js，而b.js引用了模块a。注意此时模块a的loaded属性值仍是false，因为此时模块还没加载完成。如果我们在add方法中打日志，而b.js调用a.js的add函数，则会发现此时模块a的loaded已经变成了true 从上面可以了解到，module对象下面有以下属性 id：模块id，一般默认是模块的路径 exports：模块对外导出对象，包含了对外导出的函数和属性 parent：指向首次加载本模块的模块（为什么说是首次呢？假设b.js引用了模块a，c.js引用了模块a和模块b，此时运行c.js，模块a的parent指向的是模块b） filename：模块的绝对路径 loaded：模块是否已经加载完成 children：当前模块引用的其他模块 paths：对于加载模块时没给出./ ../ /…/时，加载模块的搜索路径。依次从第一个路径搜索到最后一个路径。 exports接下来我们说说exports，在这里要了解module.exports与exports的区别。Node.js 在初始化时执行了 exports = module.exports , 所以 exports 与 module.exports 指向了相同的内存。当不改变两者的指向时，两者还是全等的。因此，我前面的写法 exports.add 只是给 exports 指向的对象上添加了add方法，并未改变其指向。这之后exports与module.exports仍是一致的。到这里大家应该明白了什么情况两者会不相等了。 123456// 如果采用这种改变指向的写法，那么之后exports与module.exports就不一样了。module.exports = { add: function (a, b) { return a + b }} 通过exports导出的函数和属性可以被其他模块调用，这一点想必大家都清楚了。 require这里先说一下模块的分类，NodeJS中模块分为核心模块和文件模块。核心模块是被编译成二进制代码，引用的时候只需require表示符即可，如require(‘fs’)，不需要加路径的。而引用文件模块时需要加上路径，表示对文件的引用。假如你加载一个自定义的test.js模块时，没有指定路径，那么它会首先从当前目录的node_modules子目录下寻找test.js，如果没有，则查找上一级目录的node_modules子目录，一直查到盘符的根目录为止。也就是前面提到的module.paths的查找顺序。 说到这里，我们再来回顾一下我们在开发时，npm install 安装的一些依赖包。它们的package.json一般都包含了main字段，用来标识入口js文件。 如果没有指定main字段，那么nodejs会默认去加载index.js或者index.node文件。例如： 看到这里，是不是突然有点懂了node_modules哪些依赖包的写法了。好的，接着往下看。 我们在c.js中打出日志，观察require方法的结构。 1console.log(require) 可以知道，require函数包含了以下属性和方法。 require.resolve()：将模块名解析，得到该模块的绝对路径 require.main：指向当前执行的主模块 require.cache：指向所有缓存的模块 require.extensions：根据文件的后缀名，调用不同的执行函数 我们再细致看一下，主要看看resolve和extensions 123456789101112var a = require('./a.js');var b = require('./b.js');console.log('resolve测试')console.log(require.resolve('./a.js'))console.log('extensions测试')console.log(require.extensions['.js'].toString())console.log(require.extensions['.json'].toString())console.log(require.extensions['.node'].toString()) 得到的结果如下图所示： 缓存使用require()加载模块是有缓存的，如果要清理缓存，则需要调用delete require.cache，示例如下： 1delete require.cache[require.resolve('./json/damei_admin.json')]; 写到这里，算是对模块有一点初步的认识。接下来我们还需要了解AMD，CMD，UMD的概念。由于篇幅太长，接下来我将分篇叙述这些概念，请阅读后续系列文章！以上观点源于自己的一些理解，如有描述不对的地方，请您指正！","link":"/回头再看JS模块化编程.html"},{"title":"撸一遍vue的基础特性","text":"Vue.js无疑是最近最火的一套渐进式前端框架。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。其轻量级，渐进式的优点对开发者的吸引力毋庸置疑。我使用过两年的Angular，对Vue也充满了好奇，于是也想认识一下Vue。 Vue.js安装主流的安装方式当然是使用vue-cli工具，这跟angular挺像的。但是作为刚入门的开发者，官方比较推荐的安装方式是直接引入script。vue脚本也分为开发版vue.js和生产版vue.min.js，开发环境下推荐使用vue.js，可以在开发过程中看到常见错误相关的警告。你可以选择使用CDN服务，直接引入这个脚本即可进行开发。 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.14/dist/vue.js\"&gt;&lt;/script&gt; 我还是习惯直接把脚本下载到项目文件夹中。 1&lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt; 学习Vue学习Vue.js最好的方法当然是把代码都撸一遍，这样印象会比较深刻。 v-if这个指令类似于angular的*ngIf，作为一个结构性指令，用来控制元素的插入和移除。当v-if=”true”时，元素正常显示；反之元素则被移除。 v-show这个指令达到的效果看起来与v-if是一样的，但是从本质上来讲是不同的。v-show其实仅仅从样式上来控制显示和隐藏，改变的是display属性。与jQuery的show()和hide()方法有异曲同工之妙。 插值表达式1&lt;span&gt;{{ content }}&lt;/span&gt; 这个是数据绑定的标准写法，与angular是一样的。content变量的值改变时，页面渲染也随之变化。插值表达式中支持js表达式。 v-html从字面意思能看出来，该指令绑定的值会输出html内容，类似于jQuery的html()方法。在angular中好像没有看到这个指令，我是自定义了一个directive来实现的。 属性绑定v-bind这个指令用来绑定元素属性，通常用于向子组件传递props。比如子组件studentList内部需要属性id来做逻辑判断，这个id可以由父组件来传递，这里就可以使用到v-bind。 1&lt;student-list v-bind:id=\"somevalue\"&gt;&lt;/student-list&gt; v-bind:可以缩写为: 1&lt;student-list :id=\"somevalue\"&gt;&lt;/student-list&gt; 事件绑定v-on用来绑定事件，比如鼠标点击事件，可以这样写： 1&lt;button v-on:click=\"toggleVueIf\"&gt;Toggle VUE IF&lt;/button&gt; v-bind:可以缩写为@： 1&lt;button @click=\"toggleVueIf\"&gt;Toggle VUE IF&lt;/button&gt; v-forv-for用来遍历数组或对象（1）数组，接收的参数上可以是两个，顺序是value, index 123&lt;ul v-for=\"(value, index) in vueForArray\"&gt; &lt;li&gt;{{ index }}: {{ value }}&lt;/li&gt;&lt;/ul&gt; （2）对象，接收的参数上可以是三个，顺序是value, key, index 123&lt;ul v-for=\"(value, key, index) in vueForObject\"&gt; &lt;li&gt;{{ index }}. {{ key }} : {{ value }}&lt;/li&gt;&lt;/ul&gt; 计算属性computed对于插值表达式中涉及到的复杂计算，建议用计算属性computed来替代。在new Vue时可以使用computed属性。 12345678// html中{{ reversedMessage }}// vue实例中computed: { reversedMessage: function() { return this.testMessage.split('').reverse().join(''); }} 这里只是一个倒序的算法，不算很复杂，只是举例说明。 watch属性我们可以使用watch来进行侦听，来响应数据的变化。上面计算属性的应用，我们也可以改用watch来写： 12345watch: { testMessage: function() { this.reversedMessage = this.testMessage.split('').reverse().join(''); }} 这里，我们通过侦听testMessage的变化来做出响应，用于改变reversedMessage的值。 ps：那么computed和watch的应用场景怎么区分？个人认为，computed更适合做一些数据值的计算，而涉及到侦听某变量需要做一些业务处理时，建议使用watch。 class绑定12&lt;!-- 类似这种形式，与属性绑定大同小异。class的绑定值可以是键值对，也可以是数组。 --&gt;&lt;div :class=\"{ category: isCategory, red: isRed }\"&gt;&lt;/div&gt; style绑定与class绑定类似，支持键值对语法（css键值对），也支持数组（多个样式对象同时作用）。 1&lt;div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt; 双向绑定v-model这一特性与angular的[(ngModel)]是一致的。通常用于表单元素。 12&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: {{ message }}&lt;/p&gt; 不过v-model还支持很多修饰符，如（1）.lazy 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; （2）.number自动将用户的输入值转为数值类型（3）.trim自动过滤用户输入的首尾空白字符 .sync看名字就知道了，同步的意思，如果绑定的属性加上这个修饰符，就实现了双向绑定。.sync破坏了单向数据流，于2.0 中移除，但又在 2.3.0 版本后以语法糖形式重新引入。 1&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt; 父子组件通信父组件通过属性传递数据给子组件props，而子组件以this.$emit(eventname, data)的方式发事件给父组件，父组件模板中需要绑定对应事件。 12345678910111213// 父组件模板，通过绑定greet传递数据给子组件，@replay接收来自子组件的事件。&lt;child :greet=\"greetMsg\" @reply=\"showReply\"&gt;&lt;/child&gt;// 子组件props属性接收props: ['greet']// 子组件模板&lt;p&gt;Greet from Father Component: {{greet}}&lt;/p&gt;&lt;button @click=\"replyToFather\"&gt;Reply&lt;/button&gt;// 点击button时调用replyToFather方法，通过$emit发送事件给父组件。methods: { replyToFather: function() { this.$emit('reply', this.replyInfo); }} slot类似angular的ng-content。父组件可以将想要的内容插在子组件的插槽中。子组件slot标签通过name属性区分插槽，如name=”slot1”，不写name属性的就是默认插槽了；而父组件要在传递给插槽的标签中加上slot属性来区分插在哪个槽中，如slot=”slot1”，如果不加slot属性，则自动插在默认插槽中。slot标签中的内容都被视为备用内容，如果父组件不给子组件传入内容，则会显示子组件slot标签中的备用内容。使用如下： 1234567891011121314151617&lt;!-- 父组件模板 --&gt;&lt;child&gt; &lt;!-- 没有指定slot属性，所以插在子组件中没有name属性的slot位置 --&gt; &lt;p&gt;Message From Father&lt;/p&gt; &lt;!-- 指定了slot属性的值为head，所以插在子组件中name属性值为head的slot位置 --&gt; &lt;p slot=\"head\"&gt;For Head&lt;/p&gt; &lt;!-- 指定了slot属性的值为foot，所以插在子组件中name属性值为foot的slot位置 --&gt; &lt;p slot=\"foot\"&gt;For Foot&lt;/p&gt; &lt;!-- 没有指定slot属性，所以插在子组件中没有name属性的slot位置 --&gt; &lt;p&gt;Other information...&lt;/p&gt;&lt;child&gt;&lt;!-- 子组件模板 --&gt;&lt;div&gt; &lt;slot name=\"head\"&gt;head content...&lt;/slot&gt; &lt;slot&gt;Backup content...&lt;/slot&gt; &lt;slot name=\"foot\"&gt;foot content...&lt;/slot&gt;&lt;/div&gt; 作用域插槽官方提供的说明我不太看得懂，根据我个人的理解，一个很重要的应用场景就是用来抽象列表式组件。比如一个展示性的列表组件，但是具体展示图文，还是其他的，需要由其父组件来指定。我这里写了一个demo。 123456789101112131415&lt;!-- 父组件模板 --&gt;&lt;my-list :items=\"movies\"&gt; &lt;template slot-scope=\"props\"&gt; &lt;li&gt; &lt;img class=\"poster\" :src=\"props.item.posterUrl\"/&gt; &lt;div&gt;{{ props.item.moviename }}&lt;/div&gt; &lt;/li&gt; &lt;!-- 我可以在这里调用各种组件，来适应各种需要，比如我可以做海报展示，那么我只要一个&lt;img&gt;;比如我只要电影名称的列表，那么就只要用到电影名称 --&gt; &lt;/template&gt;&lt;/my-list&gt;&lt;!-- 子组件模板，模板中的items是由props接收的 --&gt;&lt;ul&gt; &lt;span class=\"hot-movie\"&gt;近期热映&lt;/span&gt; &lt;slot name=\"slot-item\" v-for=\"item in items\" :item=\"item\"&gt;&lt;/slot&gt;&lt;/ul&gt; 使用要点：（1）父组件通过属性绑定将数据（一般是数组，毕竟是用于列表展示嘛）传递给子组件。 1&lt;my-list :items=\"movies\"&gt;&lt;/my-list&gt; （2）父组件传递给子组件的内容用template标签包裹，template标签具备slot-scope=”props”，props来源于子组件slot标签绑定的属性集，而本例中slot标签绑定了item属性，所以template中的内容可以调用props.item下的属性。 动态组件利用component标签及其is属性可以动态切换组件。curComponent的值为组件名。 1&lt;component :is=\"curComponent\"&gt;&lt;/component&gt; keep-alive标签利用keep-alive标签包裹component标签可以让切换组件保留在内存中，可以保留它的状态，避免重新渲染。 123&lt;keep-alive&gt; &lt;component :is=\"curComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; ref属性ref属性实现了组件的引用，不过应当避免使用ref。 123&lt;ref-comp ref=\"refComp\"&gt;&lt;/ref-comp&gt;&lt;!-- 我们可以在父组件中直接改变子组件中的refValue属性 --&gt;this.$refs.refComp.refValue += 'a'; transition过渡在组件外包裹一层transition标签，name标识transition，即可为组件加上过渡效果。如： 123&lt;transition name=\"fade\"&gt; &lt;p v-show=\"showFade\"&gt;Fade&lt;/p&gt;&lt;/transition&gt; 在进入/离开的过渡中，会有 6 个 class 切换，默认 class 名称格式如下。 fade-enter // 进入过渡开始，一般在这个class下定义-过渡开始时的css状态 fade-enter-active // 进入过渡活跃状态，一般在这个-class下定义进入过渡过程中的动画 fade-enter-to // 进入过渡结束，一般在这个class下定义过渡结束时的css状态。ps：离开过渡不再说明，类似开始过渡。 fade-leave // 离开过渡开始 fade-leave-active // 离开过渡活跃状态 fade-leave-to // 离开过渡结束 我们也可以自定义过渡类名，需要增加transition标签的属性，这样就可以使用第三方的动画库了。用法如下： 123&lt;transition name=\"fade\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\"&gt; &lt;p v-show=\"showFade\"&gt;Fade&lt;/p&gt;&lt;/transition&gt; 过渡效果主要的应用场景有： v-if v-show 动态组件 transition有着一系列javascript钩子函数，从字面意思可以与过渡的class对应起来，如下所示： 1234567891011121314&lt;transition :css=\"false\" @before-enter=\"beforeEnter\" @enter=\"enter\" @after-enter=\"afterEnter\" @enter-cancelled=\"enterCancelled\" @before-leave=\"beforeLeave\" @leave=\"leave\" @after-leave=\"afterLeave\" @leave-cancelled=\"leaveCancelled\"&gt;......&lt;/transition&gt; 钩子函数都有参数el，用于引用添加了transition包裹的元素。enter和leave钩子函数中额外有一个参数done，done是一个回调函数，是必须在最后调用的。否则，它们会被同步调用，过渡会立即完成。 1234enter: function (el, done) { // ... done();} 有了js钩子函数，那么我就可以不使用class来定义过渡的效果了，我可以使用js动画库，如velocity.js，这个时候最好添加v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 我们可以给元素设置初始渲染的过渡效果。 123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; appear拥有相同的class钩子和js钩子，也可以自定义类名。 多个元素的过渡transition中多个元素过渡时，可以这样写，给每个元素加上key属性来作为唯一标识： 12345678&lt;transition&gt; &lt;button v-if=\"isEditing\" key=\"save\"&gt; Save &lt;/button&gt; &lt;button v-else key=\"edit\"&gt; Edit &lt;/button&gt;&lt;/transition&gt; 上述代码也可以简写为绑定key的形式，而不再需要if，else： 12345&lt;transition&gt; &lt;button :key=\"isEditing\"&gt; {{ isEditing ? 'Save' : 'Edit' }} &lt;/button&gt;&lt;/transition&gt; 其中的isEditing ? ‘Save’ : ‘Edit’也可以抽象为一个computed属性。 除了多个元素的过渡，类似的还有动态组件的过渡。 123&lt;transition name=\"fade-dynamic\" mode=\"out-in\"&gt; &lt;component :is=\"curComponent\"&gt;&lt;/component&gt;&lt;/transition&gt; mode属性定义了过渡模式，防止当前元素的离开与下一个元素的进入产生重叠现象： in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。 列表过渡列表过渡用到的组件是transition-group。transition-group会以真实的元素存在于html文档中，而transition是不存在于html文档中的。transition-group存在的形式由tag属性指定，如 12345&lt;transition-group name=\"group-list\" tag=\"div\"&gt; &lt;div v-for=\"item in groups\" :key=\"item.id\" class=\"group-item\"&gt; &lt;img class=\"group-item-img\" :src=\"item.picUrl\"/&gt; &lt;/div&gt;&lt;/transition-group&gt; 为了让group-list的过渡效果平滑，有一个v-move属性，也是通过绑定class实现 123.group-list-move { transition: transform 1s;} 另一种实现方式如下： 1234567891011121314151617181920212223242526272829.group-item { margin: 10px; display: inline-block; width: 100px; height: 60px; transition: all 1s;}.group-item-img { width: 100%; height: 100%;}/* 这个作用是让元素在离开的过程中不占位，使过渡看起来十分平滑 */.group-list-leave-active { position: absolute;}/* .group-list-enter-active, .group-list-leave-active { transition: all 1s;} */.group-list-enter, .group-list-leave-to { opacity: 0; transform: translateY(30px);}/* move属性作用于元素的改变定位的过程中，这里会让transform有一个过渡效果；如果需要让列表整体有一个整体性过渡，那么可以在group-item类中加上transition属性，那么也就不需要group-list-enter-active和group-list-leave-active类中有transition属性了。*//* .group-list-move { transition: transform 1s;} */ mixinmixin是一种提高编写效率的写法，详情请参考mixin。 vue自定义指令一个指令定义对象可以提供如下几个钩子函数。 bind：只调用一次，指令第一次绑定到元素时调用。 inserted：被绑定元素插入父节点时调用 update componentUpdated unbind 目前未对指令进行深究，只写了一个简单的指令。 1234567directives: { autoClick: { inserted: function(el) { el.click(); } }} vue组件生命周期参考：（1）Vue2.0 探索之路——生命周期和钩子函数的一些理解（2）API","link":"/撸一遍vue的基础特性.html"},{"title":"前端攻城狮HTML5自查手册","text":"前言HTML5自2014年发布以来，已经有快5个年头了。但是很多人对H5有哪些新特性，兼容性如何仍然是一头雾水的。为了让自己以后方便查阅，本文整理一下H5的相关知识点，不做深入的探讨，错误之处还请指正！ HTML5标签上的改动HTML 5 参考手册 废弃或不支持的标签 &lt;acronym&gt; 定义首字母缩略词。HTML5 不支持 &lt;acronym&gt; 标签。请使用 &lt;abbr&gt; 标签代替它。 &lt;applet&gt; 可以嵌入Java语言编写的小应用程序。HTML5 不支持 &lt;applet&gt; 标签。请使用 &lt;object&gt; 标签代替它。在 HTML 4.01 中，&lt;applet&gt; 元素 已废弃。 &lt;basefont&gt; 只有 IE 9 和更早版本的 IE 浏览器支持 &lt;basefont&gt; 标签。应该避免使用该标签。在 HTML 4.01 中，&lt;basefont&gt; 元素 已废弃。 &lt;big&gt; 用来制作更大的文本。HTML5 不支持 &lt;big&gt; 标签。请用 CSS 代替。 &lt;center&gt; 对其所包括的文本进行水平居中。在 HTML 4.01 中，&lt;center&gt; 元素 已废弃 &lt;dir&gt; 被用来定义目录列表，类似ul，ol。在 HTML 4.01 中，&lt;dir&gt; 元素 已废弃。 &lt;font&gt; 规定文本的字体、字体尺寸、字体颜色。在 HTML 4.01 中，&lt;font&gt; 元素 已废弃。 &lt;frame&gt; 定义 中的子窗口（框架），必须放在&lt;frameset&gt;标签中，且不能与&lt;body&gt;共存。HTML5 不支持 &lt;frame&gt; 标签。 &lt;frameset&gt; 定义一个框架集，被用来组织一个或者多个&lt;frame&gt;元素。每个&lt;frame&gt;有各自独立的文档。HTML5 不支持&lt;frameset&gt;标签。 &lt;isindex&gt; 使浏览器显示一个对话框，提示用户输入单行文本，该特性已经从 Web 标准中删除。 &lt;noframes&gt; 可为那些不支持框架的浏览器显示文本。HTML5 不支持 &lt;noframes&gt;标签。 123456&lt;frameset cols=&quot;25%,50%,25%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot;&gt; &lt;frame src=&quot;frame_b.htm&quot;&gt; &lt;frame src=&quot;frame_c.htm&quot;&gt; &lt;noframes&gt;Sorry, your browser does not handle frames!&lt;/noframes&gt;&lt;/frameset&gt; &lt;strike&gt; 定义加删除线文本。在 HTML 4.01 中，&lt;strike&gt; 元素 已废弃。HTML5 不支持 &lt;strike&gt; 标签。请用 &lt;del&gt; 标签代替。 &lt;tt&gt; 定义打字机文本。HTML5 不支持&lt;tt&gt;标签。请用 CSS 代替。 新增的标签IE 9+、Firefox、Opera、Chrome 和 Safari 都支持新增的大部分 H5 标签。 结构标签 &lt;main&gt; 规定文档的主要内容。在一个文档中，不能出现一个以上的 &lt;main&gt; 元素。&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。所有浏览器都支持&lt;main&gt;标签，除了 Internet Explorer。 &lt;article&gt; 定义独立的内容，内容本身必须是有意义的且必须是独立于文档的其余部分。比如：论坛帖子，博客文章，新闻故事，评论。 &lt;aside&gt; 常用作侧边栏。 &lt;section&gt; 定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域。 &lt;header&gt; 定义文档或者文档的一部分区域的页眉。 &lt;hgroup&gt; 被用来对标题元素进行分组。 &lt;footer&gt; 定义文档或者文档的一部分区域的页脚。 &lt;nav&gt; 定义导航链接的部分。 媒体标签 &lt;audio&gt; 定义声音，比如音乐或其他音频流。支持的3种文件格式：MP3、Wav、Ogg。 &lt;video&gt; 定义视频，比如电影片段或其他视频流。支持三种视频格式：MP4、WebM、Ogg。 &lt;track&gt; 为媒体元素（比如 &lt;audio&gt; and &lt;video&gt;）规定外部文本轨道。IE 10、Opera 和 Chrome 浏览器支持 &lt;track&gt; 标签，其他浏览器不支持。 &lt;source&gt; 为媒体元素（比如 &lt;audio&gt; and &lt;video&gt;）定义媒体资源。 其他标签 &lt;canvas&gt; 画布，可以绘制丰富的图形，赋予了html更多想象的空间。 &lt;datalist&gt; 配合&lt;option&gt;标签制作下拉列表，与&lt;select&gt;不同的一点是，&lt;datalist&gt;支持输入，模糊匹配。 &lt;details&gt; 类似于折叠面板的一个控件，规定了用户可见的或者隐藏的需求的补充细节。&lt;summary&gt;标签可以为 &lt;details&gt; 定义标题。标题是可见的，用户点击标题时，会显示出 &lt;details&gt;。目前，只有 Chrome 和 Safari 6 支持 &lt;details&gt; 标签。 &lt;summary&gt; 与&lt;details&gt;标签配合使用。只有 Chrome 和 Safari 6 支持 &lt;summary&gt; 标签。 &lt;embed&gt; 定义了一个容器，用来嵌入外部应用或者互动程序（插件），例如flash等。 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figcaption&gt; &lt;figcaption&gt;元素被用来为&lt;figure&gt;元素定义标题。 &lt;mark&gt; 定义带有记号的文本。请在需要突出显示文本时使用&lt;mark&gt; 标签。 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。不能作为一个进度条来使用。Firefox、Opera、Chrome 和 Safari 6 支持 &lt;meter&gt; 标签。IE不支持该标签。 &lt;progress&gt; 定义运行中的任务进度（进程）。有value和max属性。 &lt;output&gt; 作为计算结果输出显示(比如执行脚本的输出)。配合两个&lt;input&gt;使用，可实时求和。Internet Explorer 浏览器不支持 &lt;output&gt; 标签。 &lt;ruby&gt; 定义 ruby 注释（中文注音或字符）。 &lt;rp&gt; 在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。 &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音。 &lt;time&gt; 定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。用datetime属性对标签中的文字作时间解释。 &lt;bdi&gt; 允许您设置一段文本，使其脱离其父元素的文本方向设置。具体应用不详。 让IE8及以下版本也支持H5新标签我们经常会用到&lt;main&gt;、&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 、&lt;nav&gt;来进行页面布局，那么如何解决IE8及以下版本支持这些标签呢？只要利用createElement让浏览器识别这些标签，并在css中给他们设置一些属性即可，比如display:block。现成的解决方案就是htmlshiv.js。 123&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;js/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 如果有打印需求，则需要html5shiv-printshiv.js，它包含 html5shiv.js 的全部功能，并且额外支持 IE6-8 网页打印时 HTML5 元素样式化。 HTML5属性上的改动新增的属性IE 9+、Firefox、Opera、Chrome 和 Safari 都支持新增的大部分 H5 属性，特殊情况会在每一项处有说明。 HTML5标准属性 contenteditable 规定是否允许用户编辑内容。可用于制作富文本等功能。兼容性较好，见下图。 contextmenu 规定了元素的上下文菜单。当用户右击元素时将显示上下文菜单。contextmenu 属性的值是需要打开的&lt;menu&gt;元素的 id。兼容性不好，目前只有 Firefox 浏览器支持 contextmenu 属性。 data-* 管理自定义属性。自定义属性可通过元素的dataset进行访问。如ele.dataset.customAttr。 兼容性见下图，IE6~8也支持data-*，但是不能通过dataset访问，必须用getAttribute访问。 draggable 规定元素是否可拖动。链接和图像默认是可拖动的。 1&lt;element draggable=&quot;true|false|auto&quot;&gt; 主要关注的内容有属性draggable，事件ondragstart，事件ondragover，事件ondrop，数据属性dataTransfer，以及dataTransfer下的两个方法setData和getData。 简单demo可以参考HTML5拖放教程。 hidden hidden 属性规定对元素进行隐藏。IE兼容性不太好，避免使用，用css替代即可。 spellcheck 规定是否对元素内容进行拼写检查。启用后会对单词进行拼写检查，不正确的单词会有波浪线提示。Internet Explorer 10, Firefox, Opera, Chrome, 和 Safari 浏览器支持 spellcheck 属性。 1&lt;element spellcheck=&quot;true|false&quot;&gt; 更丰富的表单input支持更多type HTML5 中的新类型：color、date、datetime、datetime-local、month、week、time、email、number、range、search、tel 和 url。其实也是一种语义化的表现。 值 描述 color 定义拾色器。兼容性很差，对IE，Edge，Safari等浏览器不友好，详细情况见兼容性 date 定义 date 控件（包括年、月、日，不包括时间）。兼容性很差。 datetime 定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC 时区）。兼容性很差。 datetime-local 定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）。兼容性很差。 month 定义 month 和 year 控件（不带时区）。兼容性很差。 week 定义 week 和 year 控件（不带时区）。兼容性很差。 time 定义用于输入时间的控件（不带时区）。兼容性很差。 email 定义用于 e-mail 地址的字段。会对邮箱进行格式检查。支持IE10以上，详细情况见兼容性 number 定义用于输入数字的字段。在各个浏览器上有一些差异 range 定义滑块。支持IE10以上，详细情况见兼容性 search 定义用于输入搜索字符串的文本字段。支持IE10以上，但是在UI表现上与text没有差别。查看详情 tel 定义用于输入电话号码的字段。支持IE10以上，详细情况见兼容性 url 定义用于输入 URL 的字段。会对url进行格式检查。支持IE10以上，详细情况见兼容性 其他表单控件属性 属性 描述 placeholder 可描述输入字段预期值的简短的提示信息，支持IE10以上，适用于下面的 input 类型：text、search、url、tel、email 和 password。 autofocus 页面加载时自动获得焦点，支持IE10以上。 multiple 规定允许用户输入到 input 元素的多个值。适用于以下 input 类型：email 和 file。常见于上传文件时选择多个文件。 form 规定 input 元素所属的一个或多个表单的 id 列表，以空格分隔。可以实现将 input 放在 form 标签外部。但是不支持IE。 required 规定必需在提交表单之前填写输入字段，支持IE10以上。 maxlength 规定 input 元素中允许的最大字符数，适用于text类型。 minlength 规定 input 元素中允许的最小字符数，适用于text类型。 max 规定 input 元素的最大值，max 和 min 属性适用于以下 input 类型：number、range、date、datetime、datetime-local、month、time 和 week。支持IE10以上，不支持firefox，其中IE10不支持max用于date 和 time类型。 min 规定 input 元素的最小值。 pattern 规定 input 元素的正则表达式校验。适用于下面的 input 类型：text、search、url、tel、email 和 password。应该配合 title 属性提示用户。 # HTML5其他新特性 支持IE9+ ## 音视频 标签 描述 – – source 为媒体元素（比如 video 和 audio）定义媒体资源。主要定义其 src 属性和 type 属性，src 规定媒体文件的 URL，type 规定媒体资源的 MIME 类型。 audio 定义音频。对mp3文件的兼容性最好。 video 定义视频。对MP4文件的兼容性最好。 画布canvas可以说是前端高级部分了，这里一言难尽，慢慢学习吧。支持IE9+。与之相关的svg也是支持IE9+。 Web存储主要包括sessionStorage和localStorage，操作的API都类似，区别是sessionStorage是会话级存储，localStorage是持久化存储。兼容性挺好，支持IE8+。 地理定位geolocationnavigator下的一个属性，鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。支持IE9+。 HTML5 Application Cache实现网页离线访问的利器。支持IE10+。相关的最新技术还有PWA等。 Web Worker让js也能做多线程的事情，相关内容可以参考Web Worker 使用教程。MDN上也有比较详细的解释。 HTML 5 服务器发送事件 EventSourceEventSource 接口用于接收服务器发送的事件。它通过HTTP连接到一个服务器，以text/event-stream 格式接收事件, 不关闭连接(即长连接)。兼容性不是很好，IE和Edge直接废了。不过有一个兼容方案 event-source-polyfill。 HTML5 WebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。对IE10+能较好兼容，对于不兼容的浏览器，也有很多优雅降级方案，一般是降级成ajax轮询等，像socket.io。 通知接口NotificationNotifications API 的通知接口用于向用户显示桌面通知。查看具体用法。兼容性不是很好，但是用起来网站的逼格高不少，如果是IE就直接放弃吧。","link":"/前端攻城狮HTML5自查手册.html"}],"tags":[{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"电脑技能","slug":"电脑技能","link":"/tags/电脑技能/"},{"name":"微信公众号","slug":"微信公众号","link":"/tags/微信公众号/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"TortoiseGIT","slug":"TortoiseGIT","link":"/tags/TortoiseGIT/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"socket.io","slug":"socket-io","link":"/tags/socket-io/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"Gulp","slug":"Gulp","link":"/tags/Gulp/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Next主题","slug":"Next主题","link":"/tags/Next主题/"},{"name":"valine","slug":"valine","link":"/tags/valine/"},{"name":"百度统计","slug":"百度统计","link":"/tags/百度统计/"},{"name":"CNZZ统计","slug":"CNZZ统计","link":"/tags/CNZZ统计/"},{"name":"livere","slug":"livere","link":"/tags/livere/"},{"name":"gitment","slug":"gitment","link":"/tags/gitment/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jdk","slug":"jdk","link":"/tags/jdk/"},{"name":"sea.js","slug":"sea-js","link":"/tags/sea-js/"},{"name":"require.js","slug":"require-js","link":"/tags/require-js/"},{"name":"ng-zorro","slug":"ng-zorro","link":"/tags/ng-zorro/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"vue作用域插槽","slug":"vue作用域插槽","link":"/tags/vue作用域插槽/"},{"name":"vue升级","slug":"vue升级","link":"/tags/vue升级/"},{"name":"http-server","slug":"http-server","link":"/tags/http-server/"},{"name":"demo","slug":"demo","link":"/tags/demo/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/微信小程序/"},{"name":"地图曲线","slug":"地图曲线","link":"/tags/地图曲线/"},{"name":"域名解析","slug":"域名解析","link":"/tags/域名解析/"},{"name":"前后端分离","slug":"前后端分离","link":"/tags/前后端分离/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"呼吸灯","slug":"呼吸灯","link":"/tags/呼吸灯/"},{"name":"js模块化","slug":"js模块化","link":"/tags/js模块化/"},{"name":"记事本","slug":"记事本","link":"/tags/记事本/"},{"name":"CSS单位","slug":"CSS单位","link":"/tags/CSS单位/"},{"name":"自定义tabbar","slug":"自定义tabbar","link":"/tags/自定义tabbar/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"滑块美化","slug":"滑块美化","link":"/tags/滑块美化/"},{"name":"Chrome自动填充","slug":"Chrome自动填充","link":"/tags/Chrome自动填充/"},{"name":"npm速度慢","slug":"npm速度慢","link":"/tags/npm速度慢/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"iconfont","slug":"iconfont","link":"/tags/iconfont/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"}],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"源码分析","slug":"源码分析","link":"/categories/源码分析/"},{"name":"电脑技能","slug":"电脑技能","link":"/categories/电脑技能/"},{"name":"微信公众号","slug":"微信公众号","link":"/categories/微信公众号/"},{"name":"编码规范","slug":"编码规范","link":"/categories/编码规范/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"Gulp","slug":"Gulp","link":"/categories/Gulp/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Demo","slug":"Demo","link":"/categories/Demo/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"运维","slug":"运维","link":"/categories/运维/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"SASS","slug":"SASS","link":"/categories/SASS/"},{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"记事本","slug":"记事本","link":"/categories/记事本/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/微信小程序/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"web前端","slug":"web前端","link":"/categories/web前端/"},{"name":"npm","slug":"npm","link":"/categories/npm/"},{"name":"HTML5","slug":"HTML5","link":"/categories/HTML5/"}]}